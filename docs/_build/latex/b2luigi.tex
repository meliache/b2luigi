%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{b2luigi Documentation}
\date{Apr 24, 2020}
\release{0.4.4}
\author{Nils Braun}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxcode{\sphinxupquote{b2luigi}} \sphinxhyphen{} bringing batch 2 luigi!

\sphinxcode{\sphinxupquote{b2luigi}} is a helper package for  \sphinxcode{\sphinxupquote{luigi}} for scheduling large luigi workflows on a batch system.
It is as simple as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}


\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{LocalTarget}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{output}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is a test}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MyTask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{batch}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Jump right into it with out {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}}.

If you have never worked with \sphinxcode{\sphinxupquote{luigi}} before, you may want to have a look into the \sphinxhref{http://luigi.readthedocs.io/en/stable/}{luigi documentation}.
But you can learn most of the nice features also from this documentation!

\begin{sphinxadmonition}{attention}{Attention:}
The API of \sphinxcode{\sphinxupquote{b2luigi}} is still under construction.
Please remember this when using the package in production!
\end{sphinxadmonition}


\chapter{Why not use the already created batch tasks?}
\label{\detokenize{index:why-not-use-the-already-created-batch-tasks}}
Luigi already contains a large set of tasks for scheduling and monitoring batch jobs %
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxurl{https://github.com/spotify/luigi/blob/master/luigi/contrib/sge.py}
%
\end{footnote}.
But for thousands of tasks in very large projects with different task\sphinxhyphen{}defining libraries, you have some problems:
\begin{itemize}
\item {} 
\sphinxstylestrong{You want to run many (many many!) batch jobs in parallel}
In other luigi batch implementations, for every running batch job you also need a running task that monitors it.
On most of the systems, the maximal number of processes is limited per user, so you will not be able to run more
batch jobs than this.
But what do you do if you have thousands of tasks to do?

\item {} 
\sphinxstylestrong{You have already a large set of luigi tasks in your project}
In other implementations you either have to override a \sphinxcode{\sphinxupquote{work}} function (and you are not allowed to touch
the \sphinxcode{\sphinxupquote{run}} function) or they can only run an external command, which you need to define.
The first approach plays not well when mixing non\sphinxhyphen{}batch and batch task libraries and the second
has problems when you need to pass complex arguments to the external command (via command line).

\item {} 
\sphinxstylestrong{You do not know which batch system you will run on}
Currently, the batch tasks are mostly defined for a specific batch system. But what if you want to
switch from AWS to Azure? From LSF to SGE?

\end{itemize}

Entering \sphinxcode{\sphinxupquote{b2luigi}}, which tries to solve all this (but was heavily inspired by the previous implementations):
\begin{itemize}
\item {} 
You can run as many tasks as your batch system can handle in parallel! There will only be a single process running
on your submission machine.

\item {} 
No need to rewrite your tasks! Just call them with \sphinxcode{\sphinxupquote{b2luigi.process(.., batch=True)}} or with
\sphinxcode{\sphinxupquote{python file.py \sphinxhyphen{}\sphinxhyphen{}batch}} and you are ready to go!

\item {} 
Switching the batch system is just a single change in a config file or one line in python.
In the future, there will even be an automatic discovery of the batch system to use.

\end{itemize}


\chapter{It this the only thing I can do with b2luigi?}
\label{\detokenize{index:it-this-the-only-thing-i-can-do-with-b2luigi}}
As \sphinxcode{\sphinxupquote{b2luigi}} should help you with large luigi projects, we have also included some helper functionalities for
\sphinxcode{\sphinxupquote{luigi}} tasks and task handling.
\sphinxcode{\sphinxupquote{b2luigi}} task is a super\sphinxhyphen{}hero version of \sphinxcode{\sphinxupquote{luigi}} task, with simpler handling for output and input files.
Also, we give you working examples and best\sphinxhyphen{}practices for better data management and how to accomplish your goals,
that we have learned with time.


\chapter{Why are you still talking, lets use it!}
\label{\detokenize{index:why-are-you-still-talking-lets-use-it}}
Have a look into the {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}}.

You can also start reading the {\hyperref[\detokenize{documentation/api:api-documentation-label}]{\sphinxcrossref{\DUrole{std,std-ref}{API Documentation}}}} or the code on \sphinxhref{https://github.com/nils-braun/b2luigi}{github}.

If you find any bugs or want to improve the documentation, please send me a pull request.

This project is in beta. Please be extra cautious when using in production mode.
You can help me by working with one of the todo items described in {\hyperref[\detokenize{advanced/development:development-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Development and TODOs}}}}.


\chapter{Content}
\label{\detokenize{index:content}}

\section{Installation}
\label{\detokenize{usage/installation:installation}}\label{\detokenize{usage/installation:installation-label}}\label{\detokenize{usage/installation::doc}}
This installation description is for the general user. If you are using the Belle II software, see below:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Setup your local environment.
For example, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{source} venv/bin/activate
\end{sphinxVerbatim}

\item {} 
Install b2luigi from pipy into your environment.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
If you have a local installation, you can use the normal setup command

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install b2luigi
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{1}
\item {} 
If this fails because you do not have write access to where your virtual environment lives, you can also install
b2luigi locally:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install \PYGZhy{}\PYGZhy{}user b2luigi
\end{sphinxVerbatim}

This will automatically also install \sphinxtitleref{luigi} into your current environment.
Please make sure to always setup your environment correctly before using \sphinxtitleref{b2luigi}.

\end{enumerate}

Now you can go on with the {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}}.


\subsection{b2luigi and Belle II}
\label{\detokenize{usage/installation:b2luigi-and-belle-ii}}
Starting from release 04\sphinxhyphen{}00\sphinxhyphen{}00, \sphinxtitleref{b2luigi} is already included in the externals.
Follow this guid, if you want to update to the newest version nevertheless.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Setup your local environment. You can use a local environment (installed on your machine) or a release on cvmfs.
For example, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{source} /cvmfs/belle.cern.ch/tools/b2setup prerelease\PYGZhy{}02\PYGZhy{}00\PYGZhy{}00c
\end{sphinxVerbatim}

Or you setup your local installation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} release\PYGZhy{}directory
\PYG{n+nb}{source} tools\PYGZhy{}directory/b2setup
\end{sphinxVerbatim}

\item {} 
Install b2luigi from pipy into your environment.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
If you have a local installation, you can use the normal setup command

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install b2luigi \PYGZhy{}U
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{1}
\item {} 
If you are using an installation from cvmfs, you need to add the \sphinxcode{\sphinxupquote{user}} flag.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install \PYGZhy{}\PYGZhy{}user b2luigi \PYGZhy{}U
\end{sphinxVerbatim}

\end{enumerate}

The examples in this documentation are all shown with calling \sphinxcode{\sphinxupquote{python}}, but basf2 users need to use \sphinxcode{\sphinxupquote{python3}}
instead.

Please also have a look into the {\hyperref[\detokenize{advanced/basf2-examples:basf2-example-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Belle II specific examples}}}}.


\section{Quick Start}
\label{\detokenize{usage/quickstart:quick-start}}\label{\detokenize{usage/quickstart:quick-start-label}}\label{\detokenize{usage/quickstart::doc}}
We use a very simple task definition file and submit it to a LSF batch system.

\begin{sphinxadmonition}{hint}{Hint:}
The default batch system currently is LSF, so if you do not change it, LSF will be
used. Check out {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}} for more information.
\end{sphinxadmonition}

Our task will be very simple: we want to create 100 files with some random number in it.
Later, we will build the average of those numbers.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Open a code editor and create a new file \sphinxcode{\sphinxupquote{simple\sphinxhyphen{}example.py}} with the following content:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{class} \PYG{n+nc}{MyNumberTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{some\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{LocalTarget}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results/output\PYGZus{}file\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{some\PYGZus{}parameter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{random\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{output}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}number}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{p}{[}\PYG{n}{MyNumberTask}\PYG{p}{(}\PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} 
                    \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\end{sphinxVerbatim}

Each building block in \sphinxcode{\sphinxupquote{(b2)luigi}} is a {\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.Task}}}}}.
It defines (which its run function), what should be done.
A task can have parameters, as in our case the \sphinxcode{\sphinxupquote{some\_parameter}} defined in line 6.
Each task needs to define, what it will output in its \sphinxcode{\sphinxupquote{output}} function.

\begin{sphinxadmonition}{note}{Note:}
We have defined a result path in the script with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

You can ignore that for not \sphinxhyphen{} we will come back to it later.
\end{sphinxadmonition}

In our run function, we generate a random number and write it to the output file,
which is named after the parameter of the task and stored in a result folder.

\begin{sphinxadmonition}{hint}{Hint:}
For those of you who have already used \sphinxcode{\sphinxupquote{luigi}} most of this seems familiar.
Actually, \sphinxcode{\sphinxupquote{b2luigi}}’s task is a superset of \sphinxcode{\sphinxupquote{luigi}}’s, so you can reuse
your old scripts!
\sphinxcode{\sphinxupquote{b2luigi}} will not care, which one you are using.
But we strongly advice you to use \sphinxcode{\sphinxupquote{b2luigi}}’s task, as it has some more
superior functions (see below).
\end{sphinxadmonition}

Please not that we could have imported \sphinxcode{\sphinxupquote{b2luigi}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi} \PYG{k}{as} \PYG{n+nn}{luigi}
\end{sphinxVerbatim}

to make the transition between \sphinxcode{\sphinxupquote{b2luigi}} and \sphinxcode{\sphinxupquote{luigi}} even simpler.
\end{quote}

\item {} 
Call the newly created file with python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python simple\PYGZhy{}example.py \PYGZhy{}\PYGZhy{}batch
\end{sphinxVerbatim}

Instead of giving the batch parameter in as argument, you can also add it
to the \sphinxcode{\sphinxupquote{luigi.process(.., batch=True)}} call.

Each task will be scheduled as a batch job to your LSF queue.
Using the dependency management of \sphinxcode{\sphinxupquote{luigi}}, the batch jobs are only scheduled when all dependencies are fulfilled
saving you some unneeded CPU time on the batch system.
This means although you have requested 200 workers, you only need
100 workers to fulfill the tasks, so only 100 batch jobs will be started.
On your local machine runs only the scheduling mechanism needing only a small amount of a single CPU power.

\begin{sphinxadmonition}{hint}{Hint:}
If you have no LSF queue ready or you do not want to run on the batch,
you can also remove the \sphinxtitleref{batch} argument.
This will fall back to a normal \sphinxcode{\sphinxupquote{luigi}} execution.
Please see {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}} for more information on batch execution
and the discussion of other batch systems.
\end{sphinxadmonition}

\item {} 
After the job is completed, you will see something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{==}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Luigi} \PYG{n}{Execution} \PYG{n}{Summary} \PYG{o}{==}\PYG{o}{==}\PYG{o}{=}

\PYG{n}{Scheduled} \PYG{l+m+mi}{100} \PYG{n}{tasks} \PYG{n}{of} \PYG{n}{which}\PYG{p}{:}
\PYG{o}{*} \PYG{l+m+mi}{100} \PYG{n}{ran} \PYG{n}{successfully}\PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{100} \PYG{n}{MyTask}\PYG{p}{(}\PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{18}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}

\PYG{n}{This} \PYG{n}{progress} \PYG{n}{looks} \PYG{p}{:}\PYG{p}{)} \PYG{n}{because} \PYG{n}{there} \PYG{n}{were} \PYG{n}{no} \PYG{n}{failed} \PYG{n}{tasks} \PYG{o+ow}{or} \PYG{n}{missing} \PYG{n}{dependencies}

\PYG{o}{==}\PYG{o}{==}\PYG{o}{=} \PYG{n}{Luigi} \PYG{n}{Execution} \PYG{n}{Summary} \PYG{o}{==}\PYG{o}{==}\PYG{o}{=}
\end{sphinxVerbatim}

The log files for each task are written to the \sphinxcode{\sphinxupquote{logs}} folder.

After a job is submitted, \sphinxcode{\sphinxupquote{b2luigi}} will check if it is still running or not and handle failed or done tasks correctly.

\item {} 
The defined output file names will in most of the cases depend on the parameters of the task, as
you do not want to override your files from different tasks.
However this means, you always need to include all parameters in the file name to keep them different.
This cumbersome work can be handled by \sphinxcode{\sphinxupquote{b2luigi}} automatically ,
which will also help you ordering your files at no cost.
This is especially useful in larger projects, when many people are defining and executing tasks.

This code listing shows the same task, but this time written using the helper
functions given by \sphinxcode{\sphinxupquote{b2luigi}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{class} \PYG{n+nc}{MyNumberTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{some\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{random\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}number}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{p}{[}\PYG{n}{MyNumberTask}\PYG{p}{(}\PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                     \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\end{sphinxVerbatim}

Before continuing, remove the output of the former calculation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rm \PYGZhy{}rf results
\end{sphinxVerbatim}

If you now call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python simple\PYGZhy{}example.py \PYGZhy{}\PYGZhy{}batch
\end{sphinxVerbatim}

you are basically doing the same as before, with some very nice benefits:
\begin{itemize}
\item {} 
The parameter values are automatically added to the output file (have a look into the \sphinxcode{\sphinxupquote{results/}}
folder to see how it works and where the results are stored)

\item {} 
The output for different parameters are stored on different locations, so no need to fear overriding
results.

\item {} 
The format of the folder structure makes it easy to work on it using bash commands as well as
automated procedures.

\item {} 
Other files related to your job, e.g. the submission files etc. are also placed into this
folder (this is why the very first example defined it already).

\item {} 
The default is to use the folder where your script is located.

\end{itemize}

\begin{sphinxadmonition}{hint}{Hint:}
In the example, the base path for the results is defined in the python file with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Instead, you can also add a \sphinxcode{\sphinxupquote{settings.json}} with the following content
in the folder where your script lives:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
	\PYG{n+nt}{\PYGZdq{}result\PYGZus{}dir\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}results\PYGZdq{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{settings.json}} will be used by all tasks in this folder and in each sub\sphinxhyphen{}folder.
You can use it to define project settings (like result folders) and specific settings for your
local sub project. Read the documentation on {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.get\_setting()}}}}} for
more information on how to use it.
\end{sphinxadmonition}

\begin{sphinxadmonition}{attention}{Attention:}
The result path (as well as any other paths, e.g. the log folders) are always evaluated
relatively to your script file.
This means \sphinxcode{\sphinxupquote{results}} will always be created in the folder where your script is,
not where your current working directory is.
If you are unsure on the location, call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 simple\PYGZhy{}example.py \PYGZhy{}\PYGZhy{}show\PYGZhy{}output
\end{sphinxVerbatim}

More on file systems is described in {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}}, which is also mostly
true for non\sphinxhyphen{}batch calculations.
\end{sphinxadmonition}

\item {} 
Let’s add some more tasks to our little example. We want to use the currently created files
and add them all together to an average number.
So edit your example file to include the following content:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{class} \PYG{n+nc}{MyNumberTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{some\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{random\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}number}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{MyAverageTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clone}\PYG{p}{(}\PYG{n}{MyNumberTask}\PYG{p}{,} \PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Build the mean}
        \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{input\PYGZus{}file} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}input\PYGZus{}file\PYGZus{}names}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
                \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

        \PYG{n}{average} \PYG{o}{=} \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{/} \PYG{n}{counter}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{average}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MyAverageTask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\end{sphinxVerbatim}

See how we defined dependencies in line 19 with the \sphinxcode{\sphinxupquote{requires}} function.
By calling \sphinxcode{\sphinxupquote{clone}} we make sure that any parameters from the current task (which are none in our case)
are copied to the dependencies.

\begin{sphinxadmonition}{hint}{Hint:}
Again, expert \sphinxcode{\sphinxupquote{luigi}} users will not see anything new here.
\end{sphinxadmonition}

By using the helper functions {\hyperref[\detokenize{documentation/api:b2luigi.Task.get_input_file_names}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.Task.get\_input\_file\_names()}}}}}
and \sphinxcode{\sphinxupquote{b2luigi.Task.get\_output\_file()}} the output file name generation with parameters
is transparent to you as a user.
Super easy!

When you run the script, you will see that \sphinxcode{\sphinxupquote{luigi}} detects your already run files
from before (the random numbers) and will not run the task again!
It will only output a file in \sphinxtitleref{results/average.txt} with a number near 0.5.

\end{enumerate}

You are now ready to read some more documentation in {\hyperref[\detokenize{documentation/api:api-documentation-label}]{\sphinxcrossref{\DUrole{std,std-ref}{API Documentation}}}} or have a look into the {\hyperref[\detokenize{advanced/faq:faq-label}]{\sphinxcrossref{\DUrole{std,std-ref}{FAQ}}}}.
Please also check out the different {\hyperref[\detokenize{documentation/run_modes:run-modes-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Run Modes}}}}.


\section{Batch Processing}
\label{\detokenize{usage/batch:batch-processing}}\label{\detokenize{usage/batch:batch-label}}\label{\detokenize{usage/batch::doc}}
As shown in {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}}, using the batch instead of local processing is really just a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}batch}}
on the command line or calling \sphinxcode{\sphinxupquote{process}} with \sphinxcode{\sphinxupquote{batch=True}}.
However, there is more to discover!


\subsection{Choosing the batch system}
\label{\detokenize{usage/batch:choosing-the-batch-system}}
Using \sphinxcode{\sphinxupquote{b2luigi}}’s settings mechanism (described here {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.get\_setting()}}}}}) you can choose which
batch system should be used.
Currently, \sphinxcode{\sphinxupquote{htcondor}} and \sphinxcode{\sphinxupquote{lsf}} are supported.
There is also an experimental wrapper for \sphinxcode{\sphinxupquote{gbasf2}}, the Belle II
submission tool for the LHC Worlwide Computing Grid, which works for \sphinxcode{\sphinxupquote{Basf2PathTask}} tasks.
More will come soon (PR welcome!).


\subsection{Choosing the Environment}
\label{\detokenize{usage/batch:choosing-the-environment}}
If you are doing a local calculation, all calculated tasks will use the same environment (e.g. \sphinxcode{\sphinxupquote{\$PATH}} setting, libraries etc.)
as you have currently set up when calling your script(s).
This makes it predictable and simple.

Things get a bit more complicated when using a batch farm, as the workers might not have the same environment set up, the batch
submission does not copy the environment (or the local site administrators have forbidden that) or the system on the workers
is so different that copying the environment from the scheduling machine does not make sense.

Therefore \sphinxcode{\sphinxupquote{b2luigi}} provides you with three mechanism to set the environment for each task:
\begin{itemize}
\item {} 
You can give a bash script in the \sphinxcode{\sphinxupquote{env\_script}} setting (via \sphinxcode{\sphinxupquote{set\_setting()}}, \sphinxcode{\sphinxupquote{settings.json}} or for each task as usual,
see {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.get\_setting()}}}}}), which will be called even before anything else on the worker.
Use it to set up things like the path variables or the libraries (e.g. when you are using a virtual environment) and your
batch system does not support environment copy from the scheduler to the workers.
For example a useful script might look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Source my virtual environment}
\PYG{n+nb}{source} venv/bin/activate
\PYG{c+c1}{\PYGZsh{} Set some specific settings}
\PYG{n+nb}{export} MY\PYGZus{}IMPORTANT\PYGZus{}SETTING \PYG{l+m}{10}
\end{sphinxVerbatim}

\item {} 
You can set the \sphinxcode{\sphinxupquote{env}} setting to a dictionary, which contains additional variables to be set up before your job runs.
Using the mechanism described in {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.get\_setting()}}}}} it is possible to make this task\sphinxhyphen{} or even parameter\sphinxhyphen{}dependent.

\item {} 
By default, \sphinxcode{\sphinxupquote{b2luigi}} re\sphinxhyphen{}uses the same \sphinxcode{\sphinxupquote{python}} executable on the workers as you used to schedule the tasks (by calling your script).
In some cases, this specific python executable is not present on the worker or is not usable (e.g. because of different operation systems
or architectures).
You can choose a new executable with the \sphinxcode{\sphinxupquote{executable}} setting (it is also possible to just use \sphinxcode{\sphinxupquote{python3}} as the executable assuming
it is in the path).
The executable needs to be callable after your \sphinxcode{\sphinxupquote{env\_script}} or your specific \sphinxcode{\sphinxupquote{env}} settings are used.
Please note, that the \sphinxcode{\sphinxupquote{environment}} setting is a list, so you need to pass your python executable with possible arguments like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{executable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{File System}
\label{\detokenize{usage/batch:file-system}}
Depending on your batch system, the filesystem on the worker processing the task and the scheduler machine can be different or even unrelated.
Different batch systems and batch systems implementations treat this fact differently.
In the following, the basic procedure and assumption is explained.
Any deviation from this is described in the next section.

By default, \sphinxcode{\sphinxupquote{b2luigi}} needs at least two folders to be accessible from the scheduling as well as worker machine:
the result folder and the folder of your script(s).
If possible, use absolute paths for the result and log directory to prevent any problems.
Some batch systems (e.g. htcondor) support file copy mechanisms from the scheduler to the worker systems.
Please checkout the specifics below.

\begin{sphinxadmonition}{hint}{Hint:}
All relative paths given to e.g. the \sphinxcode{\sphinxupquote{result\_dir}} or the \sphinxcode{\sphinxupquote{log\_dir}} are always evaluated
relative to the folder where your script lives.
To prevent any disambiguities, try to use absolute paths whenever possible.
\end{sphinxadmonition}

Some batch system starts the job in an arbitrary folder on the workers instead of the current folder on the scheduler.
That is why \sphinxcode{\sphinxupquote{b2luigi}} will change the directory into the path of your called script before starting the job.

In case your script is accessible from a different location on the worker than on the scheduling machine, you can give the setting \sphinxcode{\sphinxupquote{working\_dir}}
to specify where the job should run.
Your script needs to be in this folder and every relative path (e.g. for results or log) will be evaluated from there.


\subsection{Drawbacks of the batch mode}
\label{\detokenize{usage/batch:drawbacks-of-the-batch-mode}}
Although the batch mode has many benefits, it would be unfair to not mention its downsides:
\begin{itemize}
\item {} 
You have to choose the queue/batch settings/etc. depending in your requirements (e.g. wall clock time) by yourself.
So you need to make sure that the tasks will actually finish before the batch system kills them because of timeout.
There is just no way for \sphinxcode{\sphinxupquote{b2luigi}} to know this beforehand.

\item {} 
There is currently no resubmission implemented.
This means dying jobs because of batch system failures are just dead.
But because of the dependency checking mechanism of \sphinxcode{\sphinxupquote{luigi}} it is simple to just redo the calculation
and re\sphinxhyphen{}calculate what is missing.

\item {} 
The \sphinxcode{\sphinxupquote{luigi}} feature to request new dependencies while task running (via \sphinxcode{\sphinxupquote{yield}}) is not implemented for
the batch mode so far.

\end{itemize}


\subsection{Batch System Specific Settings}
\label{\detokenize{usage/batch:batch-system-specific-settings}}
Every batch system has special settings.
You can look them up here:


\subsubsection{LSF}
\label{\detokenize{usage/batch:lsf}}\index{LSFProcess (class in b2luigi.batch.processes.lsf)@\spxentry{LSFProcess}\spxextra{class in b2luigi.batch.processes.lsf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.lsf.LSFProcess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.batch.processes.lsf.}}\sphinxbfcode{\sphinxupquote{LSFProcess}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.batch.processes.BatchProcess}}}}}

Reference implementation of the batch process for a LSF batch system.

Additional to the basic batch setup (see {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}}), additional
LSF\sphinxhyphen{}specific things are:
\begin{itemize}
\item {} 
the LSF queue can be controlled via the \sphinxcode{\sphinxupquote{queue}} parameter, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyLongTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{queue} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

The default is the short queue “s”.

\item {} 
By default, the environment variables from the scheduler are copied to
the workers.
This also applies we start in the same working directory and can reuse
the same executable etc.
Normally, you do not need to supply \sphinxcode{\sphinxupquote{env\_script}} or alike.

\end{itemize}

\end{fulllineitems}



\subsubsection{HTCondor}
\label{\detokenize{usage/batch:htcondor}}\index{HTCondorProcess (class in b2luigi.batch.processes.htcondor)@\spxentry{HTCondorProcess}\spxextra{class in b2luigi.batch.processes.htcondor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.htcondor.HTCondorProcess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.batch.processes.htcondor.}}\sphinxbfcode{\sphinxupquote{HTCondorProcess}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.batch.processes.BatchProcess}}}}}

Reference implementation of the batch process for a HTCondor batch system.

Additional to the basic batch setup (see {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}}), additional
HTCondor\sphinxhyphen{}specific things are:
\begin{itemize}
\item {} 
Please note that most of the HTCondor batch farms do not have the same
environment setup on submission and worker machines, so you probably want to give an
\sphinxcode{\sphinxupquote{env\_script}}, an \sphinxcode{\sphinxupquote{env}} setting and/or a different \sphinxcode{\sphinxupquote{executable}}.

\item {} 
HTCondor supports copying files from submission to workers. This means if the
folder of your script(s)/python project/etc. is not accessible on the worker, you can
copy it from the submission machine by adding it to the setting \sphinxcode{\sphinxupquote{transfer\_files}}.
This list can host both folders and files.
Please note that due to HTCondors file transfer mechanism, all specified folders
and files will be copied into the worker node flattened, so if you specify
\sphinxtitleref{a/b/c.txt} you will end up with a file \sphinxtitleref{c.txt}.
If you use the \sphinxcode{\sphinxupquote{transfer\_files}} mechanism, you need to set the \sphinxcode{\sphinxupquote{working\_dir}} setting to “.”
as the files will end up in the current worker scratch folder.
All specified files/folders should be absolute paths.

\begin{sphinxadmonition}{hint}{Hint:}
Please do not specify any parts or the full results folder. This will lead to unexpected
behavior. We are working on a solution to also copy results, but until this the
results folder is still expected to be shared.
\end{sphinxadmonition}

If you copy your python project using this setting to thw worker machine, do not
forget to actually set it up in your setup script.
Additionally, you might want to copy your \sphinxcode{\sphinxupquote{settings.json}} as well.

\item {} 
You can give an \sphinxcode{\sphinxupquote{htcondor\_setting}} dict setting flag for additional options, such as
requested memory etc. It’s value has to be a dictionary containing HTCondor settings as key/value pairs.
These options will be written into the job submission file.
For an overview of possible settings refer to the
\sphinxhref{https://htcondor.readthedocs.io/en/latest/users-manual/submitting-a-job.html\#}{HTCondor documentation}.

\end{itemize}
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{os}


\PYG{k}{class} \PYG{n+nc}{MyNumberTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{some\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{htcondor\PYGZus{}settings} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{request\PYGZus{}cpus}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{request\PYGZus{}memory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{100 MB}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I am now starting a task}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{random\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{some\PYGZus{}parameter} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}number}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{MyAverageTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{htcondor\PYGZus{}settings} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{request\PYGZus{}cpus}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{request\PYGZus{}memory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{200 MB}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clone}\PYG{p}{(}\PYG{n}{MyNumberTask}\PYG{p}{,} \PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I am now starting the average task}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        
        \PYG{c+c1}{\PYGZsh{} Build the mean}
        \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{input\PYGZus{}file} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}input\PYGZus{}file\PYGZus{}names}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
                \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

        \PYG{n}{average} \PYG{o}{=} \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{/} \PYG{n}{counter}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{average}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MyAverageTask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{batch}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{GBasf2 Wrapper for LCG}
\label{\detokenize{usage/batch:gbasf2-wrapper-for-lcg}}\index{Gbasf2Process (class in b2luigi.batch.processes.gbasf2)@\spxentry{Gbasf2Process}\spxextra{class in b2luigi.batch.processes.gbasf2}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.gbasf2.Gbasf2Process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.batch.processes.gbasf2.}}\sphinxbfcode{\sphinxupquote{Gbasf2Process}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.batch.processes.BatchProcess}}}}}

Batch process for working with gbasf2 projects on the \sphinxstyleemphasis{LHC Computing Grid} (LCG).
\begin{description}
\item[{Features}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{gbasf2 project submission}

The gbasf2 batch process takes the basf2 path returned by the \sphinxcode{\sphinxupquote{create\_path()}}
method of the task, saves it to the disk and creates a wrapper steering file that
executes the saved path. It then sends both to the LCG via
the BelleII\sphinxhyphen{}specific Dirac\sphinxhyphen{}wrapper gbasf2.

\item {} 
\sphinxstylestrong{Project status monitoring}

After the project submission, the gbasf batch process regularly checks the status
of all the jobs belonging to a gbasf2 project returns a success if
all jobs had been successful, while a single failed job results in a failed project.
You can close a running b2luigi process and then start your script again and if a
task with the same project name is running, this b2luigi gbasf2 wrapper will recognize that
and instead of resubmitting a new project, continue monitoring the running project.

\item {} 
\sphinxstylestrong{Automatic download of datasets and logs}

If all jobs had been successful, it automatically downloads the output dataset and
the log files from the job sandboxes and automatically checks if the download was successful
before moving the data to the final location. On failure, it only downloads the logs.

\item {} 
\sphinxstylestrong{Automatic rescheduling of failed jobs}

Whenever a job fails, gbasf2 reschedules it as long as the number of retries is below the
value of the setting \sphinxcode{\sphinxupquote{gbasf2\_max\_retries}}. It keeps track of the number of retries in a
local file in the \sphinxcode{\sphinxupquote{log\_file\_dir}}, so that it does not change if you close b2luigi and start it again.
Of course it does not persist if you remove that file or move to a different machine.

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{Note:}
Despite all the automatization that this gbasf2 wrapper provides, the user is expected to
have a basic understanding of how the grid works and know the basics of working
with gbasf2 commands manually.
\end{sphinxadmonition}
\begin{description}
\item[{Limitations}] \leavevmode\begin{itemize}
\item {} 
The gbasf2 batch process for luigi can only be used for tasks
inhereting from \sphinxcode{\sphinxupquote{Basf2PathTask}} or other tasks with a
\sphinxcode{\sphinxupquote{create\_path()}} method that returns a basf2 path.

\item {} 
It can only be used for pickable/serializable basf2 paths, as it stores
the path created by \sphinxcode{\sphinxupquote{create\_path}} in a python pickle file and runs that on the grid.
Therefore, \sphinxstylestrong{basf2 variable aliases are not yet supported}.

\item {} 
Changing the batch to gbasf2 means you also have to adapt the output function of your task, because the
output will not be a single root file anymore, but a collection of root files,
one for each file in the input data set, in the directory given by the setting \sphinxcode{\sphinxupquote{gbasf2\_output\_directory}}.
You should use this directory as the required output, as it is difficult to predict what the output
files will be named. The luigi gbasf2 wrapperdoesn’t merge the files and lets the user decide how he wants to
handle them.

\end{itemize}

\item[{Settings for gbasf2 tasks}] \leavevmode\begin{quote}

To submit a task with the gbasf2 wrapper, you first you have to add the property
\sphinxcode{\sphinxupquote{batch\_system = "gbasf2"}}, which sets the \sphinxcode{\sphinxupquote{batch\_system}} setting.
It is not recommended to set that setting globally, as not all tasks can be submitted to the grid,
but only tasks with a \sphinxcode{\sphinxupquote{create\_path}} method.

For gbasf2 tasks it is further required to set the settings
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_input\_dataset}}: The input dataset on the grid to use.

\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_project\_name\_prefix}}: A string with which your gbasf2 project names will start.
To ensure the project associate with each unique task (i.e. for each of luigi parameters)
is unique, the unique \sphinxcode{\sphinxupquote{task.task\_id}} is hashed and appended to the prefix
to create the actual gbasf2 project name.
Should be below 22 characters so that the project name with the hash can remain
under 32 characters.

\end{itemize}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{batch\PYGZus{}system} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gbasf2}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{gbasf2\PYGZus{}project\PYGZus{}name\PYGZus{}prefix} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{n}{significant}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n}{gbasf2\PYGZus{}input\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{n}{hashed}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

The following settings are not required as they have default values, but they are still important enough
to be explained here:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_install\_directory}}: Defaults to \sphinxcode{\sphinxupquote{\textasciitilde{}/gbasf2KEK}}. If you installed gbasf2 into another
location, you have to change that setting accordingly.

\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_output\_directory}}: Directory into which the outputs of the gbasf2 grid project will be moved
if the the dataset download via \sphinxcode{\sphinxupquote{gb2\_ds\_get}} had been successful. It defaults to the value that you
get from running \sphinxcode{\sphinxupquote{task.get\_output\_file\_name()}} on the \sphinxcode{\sphinxupquote{gbasf2\_project\_name\_prefix}}.

\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_release}}: Defaults to the release of your currently set up basf2 release.
Set this if you want the jobs to use another release on the grid.

\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_print\_status\_updates}}: Defaults to \sphinxcode{\sphinxupquote{True}}. By setting it to \sphinxcode{\sphinxupquote{False}} you can turn off the
printing of of the job summaries, that is the number of jobs in different states in a gbasf2 project.

\item {} 
\sphinxcode{\sphinxupquote{gbasf2\_max\_retries}}: Default to 0. Maximum number of times that each job in the project can be automatically
rescheduled until the project is declared as failed.

\end{itemize}

The following optional settings correspond to the equally named \sphinxcode{\sphinxupquote{gbasf}} command line options
(without the \sphinxcode{\sphinxupquote{gbasf\_}} prefix) that you can set to customize your gbasf2 project:

\sphinxcode{\sphinxupquote{gbasf2\_additional\_files}},
\sphinxcode{\sphinxupquote{gbasf2\_n\_repition\_job}},
\sphinxcode{\sphinxupquote{gbasf2\_force\_submission}},
\sphinxcode{\sphinxupquote{gbasf2\_cputime}},
\sphinxcode{\sphinxupquote{gbasf2\_evtpersec}},
\sphinxcode{\sphinxupquote{gbasf2\_priority}},
\sphinxcode{\sphinxupquote{gbasf2\_jobtype}},
\sphinxcode{\sphinxupquote{gbasf2\_basf2opt}}
\end{quote}

It is further possible to append arbitrary command line arguments to the \sphinxcode{\sphinxupquote{gbasf2}} submission command
with the \sphinxcode{\sphinxupquote{gbasf2\_additional\_params}} setting.
If you want to blacklist a grid site, you can e.g. add

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gbasf2\PYGZus{}additional\PYGZus{}params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}banned\PYGZus{}site LCG.KEK.jp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item[{Example}] \leavevmode
Here is an example file to submit an analysis path created by the script in
\sphinxcode{\sphinxupquote{examples/gbasf2/example\_mdst\_analysis}} to grid via gbasf2:
\sphinxSetupCaptionForVerbatim{File: \sphinxcode{\sphinxupquote{examples/gbasf2/gbasf2\_example.py}}}
\def\sphinxLiteralBlockLabel{\label{\detokenize{usage/batch:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{os}\PYG{n+nn}{.}\PYG{n+nn}{path} \PYG{k+kn}{import} \PYG{n}{join}

\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{from} \PYG{n+nn}{b2luigi}\PYG{n+nn}{.}\PYG{n+nn}{basf2\PYGZus{}helper}\PYG{n+nn}{.}\PYG{n+nn}{tasks} \PYG{k+kn}{import} \PYG{n}{Basf2PathTask}

\PYG{k+kn}{import} \PYG{n+nn}{example\PYGZus{}mdst\PYGZus{}analysis}


\PYG{k}{class} \PYG{n+nc}{MyAnalysisTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} set the batch\PYGZus{}system property to use the gbasf2 wrapper batch process for this task}
    \PYG{n}{batch\PYGZus{}system} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gbasf2}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Must define a prefix for the gbasf2 project name to submit to the grid.}
    \PYG{c+c1}{\PYGZsh{} b2luigi will then add a hash derived from the luigi parameters to create a unique project name.}
    \PYG{n}{gbasf2\PYGZus{}project\PYGZus{}name\PYGZus{}prefix} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{gbasf2\PYGZus{}input\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{n}{hashed}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Example luigi cut parameter to facilitate starting multiple projects for different cut values}
    \PYG{n}{mbc\PYGZus{}lower\PYGZus{}cut} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}path}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{mbc\PYGZus{}range} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mbc\PYGZus{}lower\PYGZus{}cut}\PYG{p}{,} \PYG{l+m+mf}{5.3}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{example\PYGZus{}mdst\PYGZus{}analysis}\PYG{o}{.}\PYG{n}{create\PYGZus{}analysis\PYGZus{}path}\PYG{p}{(}\PYG{n}{mbc\PYGZus{}range}\PYG{o}{=}\PYG{n}{mbc\PYGZus{}range}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gbasf2\PYGZus{}project\PYGZus{}name\PYGZus{}prefix}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{MasterTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{WrapperTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    We use the MasterTask to be able to require multiple analyse tasks with}
\PYG{l+s+sd}{    different input datasets and cut values. For each parameter combination, a}
\PYG{l+s+sd}{    different gbasf2 project will be submitted.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{input\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{join}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/belle/MC/release\PYGZhy{}04\PYGZhy{}00\PYGZhy{}03/DB00000757/MC13a/prod00009434/s00/e1003/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4S/r00000/mixed/mdst/sub00/mdst\PYGZus{}000255\PYGZus{}prod00009434\PYGZus{}task10020000255.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} if you want to iterate over different cuts, just add more values to this list}
        \PYG{n}{mbc\PYGZus{}lower\PYGZus{}cuts} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{5.15}\PYG{p}{,} \PYG{l+m+mf}{5.2}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{mbc\PYGZus{}lower\PYGZus{}cut} \PYG{o+ow}{in} \PYG{n}{mbc\PYGZus{}lower\PYGZus{}cuts}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n}{MyAnalysisTask}\PYG{p}{(}
                \PYG{n}{mbc\PYGZus{}lower\PYGZus{}cut}\PYG{o}{=}\PYG{n}{mbc\PYGZus{}lower\PYGZus{}cut}\PYG{p}{,}
                \PYG{n}{gbasf2\PYGZus{}project\PYGZus{}name\PYGZus{}prefix}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{luigiExample}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{n}{gbasf2\PYGZus{}input\PYGZus{}dataset}\PYG{o}{=}\PYG{n}{input\PYGZus{}dataset}\PYG{p}{,}
                \PYG{n}{max\PYGZus{}event}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}
            \PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{master\PYGZus{}task\PYGZus{}instance} \PYG{o}{=} \PYG{n}{MasterTask}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{n\PYGZus{}gbasf2\PYGZus{}tasks} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{master\PYGZus{}task\PYGZus{}instance}\PYG{o}{.}\PYG{n}{requires}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{master\PYGZus{}task\PYGZus{}instance}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{n}{n\PYGZus{}gbasf2\PYGZus{}tasks}\PYG{p}{)}
\end{sphinxVerbatim}

\item[{Handling failed jobs}] \leavevmode
The gbasf2 input wrapper considers the gbasf2 project as failed if any of
the jobs in the project failed and reached the maximum number of retries.
It then automatically downloads the logs, so please look into them to see what the reason was.
For example, it can be that only certain grid sites were affected, so you might want to exclude them
by adding the \sphinxcode{\sphinxupquote{"\sphinxhyphen{}\sphinxhyphen{}banned\_site ...}} to \sphinxcode{\sphinxupquote{gbasf2\_additional\_params}}.

You also always reschedule jobs manually with the \sphinxcode{\sphinxupquote{gb2\_job\_reschedule}} command or delete them with
\sphinxcode{\sphinxupquote{gb2\_job\_delete}} so that the gbasf2 batch process doesn’t know they ever
existed. Then run just run your luigi task/script again and it will start monitoring the running project
again.

\end{description}

\end{fulllineitems}



\subsection{Add your own batch system}
\label{\detokenize{usage/batch:add-your-own-batch-system}}
If you want to add a new batch system, all you need to do is to implement the
abstract functions of \sphinxcode{\sphinxupquote{BatchProcess}} for your system:
\index{BatchProcess (class in b2luigi.batch.processes)@\spxentry{BatchProcess}\spxextra{class in b2luigi.batch.processes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.batch.processes.}}\sphinxbfcode{\sphinxupquote{BatchProcess}}}{\emph{\DUrole{n}{task}}, \emph{\DUrole{n}{scheduler}}, \emph{\DUrole{n}{result\_queue}}, \emph{\DUrole{n}{worker\_timeout}}}{}
This is the base class for all batch algorithms that allow luigi to run on a specific batch system.
This is an abstract base class and inheriting classes need to supply functionalities for
* starting a job using the commands in self.task\_cmd
* getting the job status of a running, finished or failed job
* and killing a job
All those commands are called from the main process, which is not running on the batch system.
Every batch system that is capable of these functions can in principle work together with b2luigi.
\begin{description}
\item[{Implementation note:}] \leavevmode
In principle, using the batch system is transparent to the user. In case of problems, it
may however be useful to understand how it is working.

When you start your luigi dependency tree with \sphinxcode{\sphinxupquote{process(..., batch=True)}}, the normal
luigi process is started looking for unfinished tasks and running them etc.
Normally, luigi creates a process for each running task and runs them either directly
or on a different core (if you have enabled more than one worker).
In the batch case, this process is not a normal python multiprocessing process,
but this BatchProcess, which has the same interface (one can check the status of the process,
start or kill it). The process does not need to wait for the batch job to finish but
is asked repeatedly for the job status. By this, most of the core functionality of luigi
is kept and reused.
This also means, that every batch job only includes a single task and is finished whenever
this task is done decreasing the batch runtime. You will need exactly as many batch jobs
as you have tasks and no batch job will idle waiting for input data as all are scheduled
only when the task they should run is actually runnable (the input files are there).

What is the batch command now? In each job, we call a specific executable bash script
only created for this task. It contains the setup of the environment (if given by the
user via the settings), the change of the working directory (the directory of the
python script or a specified directory by the user) and a call of this script with the
current python interpreter (the one you used to call this main file or given by the
setting \sphinxcode{\sphinxupquote{executable}}) . However, we give this call an additional parameter, which tells it
to only run one single task. Task can be identified by their task id. A typical task command may look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{\PYGZlt{}}\PYG{n}{path}\PYG{o}{\PYGZhy{}}\PYG{n}{to}\PYG{o}{\PYGZhy{}}\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{exec}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{python} \PYG{o}{/}\PYG{n}{your}\PYG{o}{\PYGZhy{}}\PYG{n}{project}\PYG{o}{/}\PYG{n}{some}\PYG{o}{\PYGZhy{}}\PYG{n}{file}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{batch}\PYG{o}{\PYGZhy{}}\PYG{n}{runner} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{task}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{id} \PYG{n}{MyTask\PYGZus{}38dsf879w3}
\end{sphinxVerbatim}

if the batch job should run the MyTask. The implementation of the
abstract functions is responsible for creating an running the executable file and writing the log of
the job into appropriate locations. You can use the functions \sphinxcode{\sphinxupquote{create\_executable\_wrapper}}
and \sphinxcode{\sphinxupquote{get\_log\_file\_dir}} to get the needed information.

Checkout the implementation of the lsf task for some implementation example.

\end{description}
\index{get\_job\_status() (b2luigi.batch.processes.BatchProcess method)@\spxentry{get\_job\_status()}\spxextra{b2luigi.batch.processes.BatchProcess method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess.get_job_status}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_job\_status}}}{}{}
Implement this function to return the current job status.
How you identify exactly your job is dependent on the implementation and needs to
be handled by your own child class.

Must return one item of the JobStatus enumeration: running, aborted, successful or idle.
Will only be called after the job is started but may also be called when
the job is finished already.
If the task status is unknown, return aborted. If the task has not started already but
is scheduled, return running nevertheless (for b2luigi it makes no difference).
No matter if aborted via a call to kill\_job, by the batch system or by an exception in the
job itself, you should return aborted if the job is not finished successfully
(maybe you need to check the exit code of your job).

\end{fulllineitems}

\index{kill\_job() (b2luigi.batch.processes.BatchProcess method)@\spxentry{kill\_job()}\spxextra{b2luigi.batch.processes.BatchProcess method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess.kill_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{kill\_job}}}{}{}
This command is used to abort a job started by the start\_job function.
It is only called once to abort a job, so make sure to either block until the job is really
gone or be sure that it will go down soon. Especially, do not wait until the job is finished.
It is called for example when the user presses Ctrl\sphinxhyphen{}C.

In some strange corner cases it may happen that this function is called even before the
job is started (the start\_job function is called). In this case, you do not need to do anything
(but also not raise an exception).

\end{fulllineitems}

\index{start\_job() (b2luigi.batch.processes.BatchProcess method)@\spxentry{start\_job()}\spxextra{b2luigi.batch.processes.BatchProcess method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{usage/batch:b2luigi.batch.processes.BatchProcess.start_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{start\_job}}}{}{}
Override this function in your child class to start a job on the batch system.
It is called exactly once. You need to store any information identifying
your batch job on your own.

You can use the \sphinxcode{\sphinxupquote{b2luigi.core.utils.get\_log\_file\_dir}} and the
\sphinxcode{\sphinxupquote{b2luigi.core.executable.create\_executable\_wrapper}} functions to get the log base name
and to create the executable script which you should call in your batch job.

After the start\_job function is called by the framework (and no exception is thrown),
it is assumed that a batch job is started or scheduled.

After the job is finished (no matter if aborted or successful) we assume the stdout and stderr
is written into the two files given by b2luigi.core.utils.get\_log\_file\_dir(self.task).

\end{fulllineitems}


\end{fulllineitems}



\section{Belle II specific examples}
\label{\detokenize{advanced/basf2-examples:belle-ii-specific-examples}}\label{\detokenize{advanced/basf2-examples:basf2-example-label}}\label{\detokenize{advanced/basf2-examples::doc}}
The following examples are not of interest to the general audience, but only for basf2 users.


\subsection{Running at the NAF}
\label{\detokenize{advanced/basf2-examples:running-at-the-naf}}
The environment on the workers is different than on the scheduling machine, so we can not
just copy the environment variables as on KEKCC.

You can use setup script (e.g. called \sphinxcode{\sphinxupquote{setup\_basf2.sh}}) with the following content

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{source} /cvmfs/belle.cern.ch/tools/b2setup release\PYGZhy{}XX\PYGZhy{}XX\PYGZhy{}XX
\end{sphinxVerbatim}

All you have to do is specify the setup script as the \sphinxcode{\sphinxupquote{env\_script}} setting and also set the
executable explicitly.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{sleep}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}


\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{sleep}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parameter}\PYG{p}{)}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{Wrapper}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n}{MyTask}\PYG{p}{(}\PYG{n}{parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Choose htcondor as our batch system}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}system}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{htcondor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Setup the correct environment on the workers}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{env\PYGZus{}script}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{setup\PYGZus{}basf2.sh}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Most likely your executable from the submission node is not the same on}
    \PYG{c+c1}{\PYGZsh{} the worker node, so specify it explicitly}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{executable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Where to store the results}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{set\PYGZus{}setting}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{result\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{Wrapper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{batch}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}

Of course it is also possible to set those settings in the \sphinxcode{\sphinxupquote{settings.json}} or as task\sphinxhyphen{}specific parameters.
Please check out {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.get\_setting()}}}}} for more information.

Please note that the called script as well as the results folder need to be accessible from both
the scheduler and the worker machines.
If needed, you can also include more setup steps in the source script.


\subsection{Running at KEKCC}
\label{\detokenize{advanced/basf2-examples:running-at-kekcc}}
KEKCC uses LSF as the batch system. As this is the default for \sphinxcode{\sphinxupquote{b2luigi}} there is
nothing you need to do.


\subsection{nTuple Generation}
\label{\detokenize{advanced/basf2-examples:ntuple-generation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi} \PYG{k}{as} \PYG{n+nn}{luigi}
\PYG{k+kn}{from} \PYG{n+nn}{b2luigi}\PYG{n+nn}{.}\PYG{n+nn}{basf2\PYGZus{}helper} \PYG{k+kn}{import} \PYG{n}{Basf2PathTask}\PYG{p}{,} \PYG{n}{Basf2nTupleMergeTask}

\PYG{k+kn}{import} \PYG{n+nn}{basf2}

\PYG{k+kn}{import} \PYG{n+nn}{modularAnalysis}


\PYG{k}{class} \PYG{n+nc}{AnalysisTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{experiment\PYGZus{}number} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{run\PYGZus{}number} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{mode} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}number} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Define the outputs here}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}path}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} somehow create filenames from parameters}
        \PYG{c+c1}{\PYGZsh{} self.experiment\PYGZus{}number, self.run\PYGZus{}number,}
        \PYG{c+c1}{\PYGZsh{} self.mode and self.file\PYGZus{}number}
        \PYG{c+c1}{\PYGZsh{} (parameters just examples)}
        \PYG{n}{input\PYGZus{}file\PYGZus{}names} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}

        \PYG{n}{path} \PYG{o}{=} \PYG{n}{basf2}\PYG{o}{.}\PYG{n}{create\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{inputMdstList}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{input\PYGZus{}file\PYGZus{}names}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Now fill your particle lists, just examples}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fillParticleLists}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kaonID \PYGZgt{} 0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pi+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pionID \PYGZgt{} 0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                                          \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{reconstructDecay}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0 \PYGZhy{}\PYGZgt{} K\PYGZhy{} pi+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7 \PYGZlt{} M \PYGZlt{} 1.9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fitVertex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{matchMCTruth}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{reconstructDecay}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{} \PYGZhy{}\PYGZgt{} D0 pi\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5.2 \PYGZlt{} Mbc \PYGZlt{} 5.3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fitVertex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{matchMCTruth}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} When exporting, use the function get\PYGZus{}output\PYGZus{}file\PYGZus{}name()}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{variablesToNtuple}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useCMSFrame(p)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useCMSFrame(E)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daughter(0, kaonID)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daughter(1, pionID)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isSignal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mcErrors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                        \PYG{n}{filename}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                        \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{variablesToNtuple}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mbc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{deltaE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isSignal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mcErrors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                        \PYG{n}{filename}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                        \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{path}


\PYG{k}{class} \PYG{n+nc}{MasterTask}\PYG{p}{(}\PYG{n}{luigi}\PYG{o}{.}\PYG{n}{WrapperTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} somehow loop over the runs, experiment etc.}
            \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clone}\PYG{p}{(}\PYG{n}{AnalysisTask}\PYG{p}{,} \PYG{n}{experiment\PYGZus{}number}\PYG{o}{=}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MasterTask}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Standard Simulation, Reconstruction and some nTuple Generation}
\label{\detokenize{advanced/basf2-examples:standard-simulation-reconstruction-and-some-ntuple-generation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi} \PYG{k}{as} \PYG{n+nn}{luigi}
\PYG{k+kn}{from} \PYG{n+nn}{b2luigi}\PYG{n+nn}{.}\PYG{n+nn}{basf2\PYGZus{}helper} \PYG{k+kn}{import} \PYG{n}{Basf2PathTask}\PYG{p}{,} \PYG{n}{Basf2nTupleMergeTask}

\PYG{k+kn}{from} \PYG{n+nn}{enum} \PYG{k+kn}{import} \PYG{n}{Enum}

\PYG{k+kn}{import} \PYG{n+nn}{basf2}

\PYG{k+kn}{import} \PYG{n+nn}{modularAnalysis}
\PYG{k+kn}{import} \PYG{n+nn}{simulation}
\PYG{k+kn}{import} \PYG{n+nn}{generators}
\PYG{k+kn}{import} \PYG{n+nn}{reconstruction}
\PYG{k+kn}{from} \PYG{n+nn}{ROOT} \PYG{k+kn}{import} \PYG{n}{Belle2}


\PYG{k}{class} \PYG{n+nc}{SimulationType}\PYG{p}{(}\PYG{n}{Enum}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y4s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y(4S)}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{continuum} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Continuum}\PYG{l+s+s2}{\PYGZdq{}}


\PYG{k}{class} \PYG{n+nc}{SimulationTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n\PYGZus{}events} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{event\PYGZus{}type} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{EnumParameter}\PYG{p}{(}\PYG{n}{enum}\PYG{o}{=}\PYG{n}{SimulationType}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}path}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{path} \PYG{o}{=} \PYG{n}{basf2}\PYG{o}{.}\PYG{n}{create\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{setupEventInfo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n\PYGZus{}events}\PYG{p}{,} \PYG{n}{path}\PYG{p}{)}

        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{event\PYGZus{}type} \PYG{o}{==} \PYG{n}{SimulationType}\PYG{o}{.}\PYG{n}{y4s}\PYG{p}{:}
            \PYG{n}{dec\PYGZus{}file} \PYG{o}{=} \PYG{n}{Belle2}\PYG{o}{.}\PYG{n}{FileSystem}\PYG{o}{.}\PYG{n}{findFile}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{analysis/examples/tutorials/B2A101\PYGZhy{}Y4SEventGeneration.dec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{event\PYGZus{}type} \PYG{o}{==} \PYG{n}{SimulationType}\PYG{o}{.}\PYG{n}{continuum}\PYG{p}{:}
            \PYG{n}{dec\PYGZus{}file} \PYG{o}{=} \PYG{n}{Belle2}\PYG{o}{.}\PYG{n}{FileSystem}\PYG{o}{.}\PYG{n}{findFile}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{analysis/examples/simulations/B2A102\PYGZhy{}ccbarEventGeneration.dec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Event type }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{event\PYGZus{}type}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ is not valid. It should be either }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{Y(4S)}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ or }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{Continuum}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n}{generators}\PYG{o}{.}\PYG{n}{add\PYGZus{}evtgen\PYGZus{}generator}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{signal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dec\PYGZus{}file}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{loadGearbox}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{simulation}\PYG{o}{.}\PYG{n}{add\PYGZus{}simulation}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}

        \PYG{n}{path}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RootOutput}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{outputFileName}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{simulation\PYGZus{}full\PYGZus{}output.root}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{path}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{simulation\PYGZus{}full\PYGZus{}output.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{n+nd}{@luigi}\PYG{o}{.}\PYG{n}{requires}\PYG{p}{(}\PYG{n}{SimulationTask}\PYG{p}{)}
\PYG{k}{class} \PYG{n+nc}{ReconstructionTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}path}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{path} \PYG{o}{=} \PYG{n}{basf2}\PYG{o}{.}\PYG{n}{create\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{path}\PYG{o}{.}\PYG{n}{add\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RootInput}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{inputFileNames}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}input\PYGZus{}file\PYGZus{}names}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{simulation\PYGZus{}full\PYGZus{}output.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{loadGearbox}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{reconstruction}\PYG{o}{.}\PYG{n}{add\PYGZus{}reconstruction}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}

        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{outputMdst}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reconstructed\PYGZus{}output.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{path}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reconstructed\PYGZus{}output.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{n+nd}{@luigi}\PYG{o}{.}\PYG{n}{requires}\PYG{p}{(}\PYG{n}{ReconstructionTask}\PYG{p}{)}
\PYG{k}{class} \PYG{n+nc}{AnalysisTask}\PYG{p}{(}\PYG{n}{Basf2PathTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}path}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{path} \PYG{o}{=} \PYG{n}{basf2}\PYG{o}{.}\PYG{n}{create\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{inputMdstList}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}input\PYGZus{}file\PYGZus{}names}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{reconstructed\PYGZus{}output.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fillParticleLists}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kaonID \PYGZgt{} 0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pi+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pionID \PYGZgt{} 0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{reconstructDecay}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0 \PYGZhy{}\PYGZgt{} K\PYGZhy{} pi+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.7 \PYGZlt{} M \PYGZlt{} 1.9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fitVertex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{matchMCTruth}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{reconstructDecay}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{} \PYGZhy{}\PYGZgt{} D0 pi\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5.2 \PYGZlt{} Mbc \PYGZlt{} 5.3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{fitVertex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{matchMCTruth}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{variablesToNtuple}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                          \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useCMSFrame(p)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{useCMSFrame(E)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                           \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daughter(0, kaonID)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daughter(1, pionID)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isSignal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mcErrors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                          \PYG{n}{filename}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{modularAnalysis}\PYG{o}{.}\PYG{n}{variablesToNtuple}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                          \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mbc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{deltaE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isSignal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mcErrors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                          \PYG{n}{filename}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                          \PYG{n}{path}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{path}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B\PYGZus{}n\PYGZus{}tuple.root}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{MasterTask}\PYG{p}{(}\PYG{n}{Basf2nTupleMergeTask}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n\PYGZus{}events} \PYG{o}{=} \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{IntParameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{event\PYGZus{}type} \PYG{o+ow}{in} \PYG{n}{SimulationType}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clone}\PYG{p}{(}\PYG{n}{AnalysisTask}\PYG{p}{,} \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{n}{event\PYGZus{}type}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MasterTask}\PYG{p}{(}\PYG{n}{n\PYGZus{}events}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{workers}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}


\section{API Documentation}
\label{\detokenize{documentation/api:api-documentation}}\label{\detokenize{documentation/api:api-documentation-label}}\label{\detokenize{documentation/api::doc}}
\sphinxcode{\sphinxupquote{b2luigi}} summarizes different topics to help you in your everyday task
creation and processing.
Most important is the {\hyperref[\detokenize{documentation/api:b2luigi.process}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.process()}}}}} function, which lets you run
arbitrary task graphs on the batch.
It is very similar to \sphinxcode{\sphinxupquote{luigi.build}}, but lets you hand in additional parameters
for steering the batch execution.


\subsection{Top\sphinxhyphen{}Level Function}
\label{\detokenize{documentation/api:top-level-function}}\index{process() (in module b2luigi)@\spxentry{process()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.process}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{process}}}{\emph{\DUrole{n}{task\_like\_elements}}, \emph{\DUrole{n}{show\_output}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{dry\_run}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{test}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{batch}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Call this function in your main method to tell \sphinxcode{\sphinxupquote{b2luigi}} where your entry
point of the task graph is.
It is very similar to \sphinxcode{\sphinxupquote{luigi.build}} with some additional configuration options.
\subsubsection*{Example}

This example defines a simple task and tells \sphinxcode{\sphinxupquote{b2luigi}} to execute it 100 times
with different parametes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{class} \PYG{n+nc}{MyNumberTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{some\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{LocalTarget}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results/output\PYGZus{}file\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{some\PYGZus{}parameter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{random\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{output}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}number}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{p}{[}\PYG{n}{MyNumberTask}\PYG{p}{(}\PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

All flag arguments can also be given as command line arguments.
This means the call with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{tasks}\PYG{p}{,} \PYG{n}{batch}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

is equivalent to calling the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{batch}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{task\_like\_elements}} ({\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Task}}}}} or list) \textendash{} Task(s) to execute with luigi.
Can either be a list of tasks or a task instance.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Instead of running the task(s), write out all output files
which will be generated marked in color, if they are present already.
Good for testing of your tasks will do, what you think they should.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dry\_run}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Instead od running the task(s), write out which tasks will
be executed. This is a simplified form of dependency resolution, so this
information may be wrong in some corner cases. Also good for testing.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{test}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Does neither run on the batch system, with multiprocessing
or dispatched (see {\hyperref[\detokenize{documentation/api:b2luigi.DispatchableTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DispatchableTask}}}}}) but directly on the machine for
debugging reasons. Does output all logs to the console.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Execute the tasks on the selected batch system.
Refer to {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}} for more information.
The default batch system is LSF, but this can be changed with the \sphinxtitleref{batch\_system}
settings. See {\hyperref[\detokenize{documentation/api:b2luigi.get_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_setting}}}}} on how to define settings.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Additional keyword arguments passed to \sphinxcode{\sphinxupquote{luigi.build}}.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
You should always have just a single call to \sphinxcode{\sphinxupquote{process}} in your script.
If you need to have multiple calls, either use a {\hyperref[\detokenize{documentation/api:b2luigi.WrapperTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.WrapperTask}}}}}
or two scripts.
\end{sphinxadmonition}

\end{fulllineitems}



\subsection{Super\sphinxhyphen{}hero Task Classes}
\label{\detokenize{documentation/api:super-hero-task-classes}}
If you want to use the default \sphinxcode{\sphinxupquote{luigi.Task}} class or any derivative of it,
you are totally fine.
No need to change any of your scripts!
But if you want to take advantage of some of the recipies we have developed
to work with large luigi task sets, you can use the drop in replacements
from the \sphinxcode{\sphinxupquote{b2luigi}} package.
All task classes (except the {\hyperref[\detokenize{documentation/api:b2luigi.DispatchableTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.DispatchableTask}}}}}, see below) are superclasses of
a \sphinxcode{\sphinxupquote{luigi}} class.
As we import \sphinxcode{\sphinxupquote{luigi}} into \sphinxcode{\sphinxupquote{b2luigi}}, you just need to replace

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{luigi}
\end{sphinxVerbatim}

with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi} \PYG{k}{as} \PYG{n+nn}{luigi}
\end{sphinxVerbatim}

and you will have all the functionality of \sphinxcode{\sphinxupquote{luigi}} and \sphinxcode{\sphinxupquote{b2luigi}}
without the need to change anything!
\index{Task (class in b2luigi)@\spxentry{Task}\spxextra{class in b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.Task}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{Task}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{luigi.task.Task}}

Drop in replacement for \sphinxcode{\sphinxupquote{luigi.Task}} which is 100\% API compatible.
It just adds some useful methods for handling output file name generation using
the parameters of the task.
See {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}} on information on how to use the methods.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyAverageTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clone}\PYG{p}{(}\PYG{n}{MyNumberTask}\PYG{p}{,} \PYG{n}{some\PYGZus{}parameter}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Build the mean}
        \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{input\PYGZus{}file} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}input\PYGZus{}file\PYGZus{}names}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{input\PYGZus{}file}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
                \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

        \PYG{n}{average} \PYG{o}{=} \PYG{n}{summed\PYGZus{}numbers} \PYG{o}{/} \PYG{n}{counter}

        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{average.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{average}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\index{add\_to\_output() (b2luigi.Task method)@\spxentry{add\_to\_output()}\spxextra{b2luigi.Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.Task.add_to_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_to\_output}}}{\emph{\DUrole{n}{output\_file\_name}}}{}
Call this in your output() function to add a target to the list of files,
this task will output.
Always use in combination with \sphinxtitleref{yield}.
This function will automatically add all current parameter values to
the file name when used in the form
\begin{quote}

result\_dir/param\_1=value/param\_2=value/output\_file\_name
\end{quote}

This function will automatically use a \sphinxcode{\sphinxupquote{LocalTarget}}.
If you do not want this, you can override the \sphinxcode{\sphinxupquote{\_get\_output\_file\_target}} function.
\subsubsection*{Example}

This adds two files called \sphinxcode{\sphinxupquote{some\_file.txt}} and \sphinxcode{\sphinxupquote{some\_other\_file.txt}} to the output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{some\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{some\PYGZus{}other\PYGZus{}file.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{output\_file\_name}} (\sphinxcode{\sphinxupquote{str}}) \textendash{} the file name of the output file.
Refer to this file name as a key when using {\hyperref[\detokenize{documentation/api:b2luigi.Task.get_input_file_names}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_input\_file\_names}}}}},
\sphinxcode{\sphinxupquote{get\_output\_file\_names}} or \sphinxcode{\sphinxupquote{get\_output\_file}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_input\_file\_names() (b2luigi.Task method)@\spxentry{get\_input\_file\_names()}\spxextra{b2luigi.Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.Task.get_input_file_names}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_input\_file\_names}}}{\emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get a dictionary of input file names of the tasks, which are defined in our requirements.
Either use the key argument or dictionary indexing with the key given to {\hyperref[\detokenize{documentation/api:b2luigi.Task.add_to_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_to\_output}}}}}
to get back a list (!) of file paths.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxcode{\sphinxupquote{str}}, optional) \textendash{} If given, only return a list of file paths with this given key.

\item[{Returns}] \leavevmode
If key is none, returns a dictionary of keys to list of file paths.
Else, returns only the list of file paths for this given key.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_output\_file\_name() (b2luigi.Task method)@\spxentry{get\_output\_file\_name()}\spxextra{b2luigi.Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.Task.get_output_file_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_output\_file\_name}}}{\emph{\DUrole{n}{key}}}{}
Analogous to {\hyperref[\detokenize{documentation/api:b2luigi.Task.get_input_file_names}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_input\_file\_names}}}}} this function returns
a an output file defined in out output function with
the given key.

In contrast to {\hyperref[\detokenize{documentation/api:b2luigi.Task.get_input_file_names}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_input\_file\_names}}}}}, only a single file name
will be returned (as there can only be a single output file with a given name).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxcode{\sphinxupquote{str}}) \textendash{} Return the file path with this given key.

\item[{Returns}] \leavevmode
Returns only the file path for this given key.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExternalTask (class in b2luigi)@\spxentry{ExternalTask}\spxextra{class in b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.ExternalTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{ExternalTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{b2luigi.core.task.Task}}, \sphinxcode{\sphinxupquote{luigi.task.ExternalTask}}

Direct copy of \sphinxcode{\sphinxupquote{luigi.ExternalTask}}, but with the capabilities of {\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Task}}}}} added.

\end{fulllineitems}

\index{WrapperTask (class in b2luigi)@\spxentry{WrapperTask}\spxextra{class in b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.WrapperTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{WrapperTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{b2luigi.core.task.Task}}, \sphinxcode{\sphinxupquote{luigi.task.WrapperTask}}

Direct copy of \sphinxcode{\sphinxupquote{luigi.WrapperTask}}, but with the capabilities of {\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Task}}}}} added.

\end{fulllineitems}

\index{dispatch() (in module b2luigi)@\spxentry{dispatch()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.dispatch}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{dispatch}}}{\emph{\DUrole{n}{run\_function}}}{}
In cases you have a run function calling external, probably insecure functionalities,
use this function wrapper around your run function.
It basically \sphinxtitleref{emulates} a batch submission on your local computer (without any
batch system) with the benefit of having a totally separete execution path.
If your called task fails miserably (e.g. segfaults), it does not crash your main application.
\subsubsection*{Example}

The run function can include any code you want. When the task runs,
it is started in a subprocess and monitored by the parent process.
When it dies unexpectedly (e.g. because of a segfault etc.)
the task will be marked as failed. If not, it is successful.
The log output will be written to two files in the log folder (marked with
the parameters of the task), which you can check afterwards:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}

\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@b2luigi}\PYG{o}{.}\PYG{n}{dispatch}
    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{call\PYGZus{}some\PYGZus{}evil\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
We are reusing the batch system implementation here, with all its settings
and nobs to setup the environment etc.
If you want to control it in more detail, please check out {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}}.
\end{sphinxadmonition}
\begin{description}
\item[{Implementation note:}] \leavevmode
In the subprocess we are calling the current executable (which should by python)
with the current input file as a parameter, but let it only run this
specific task (by handing over the task id and the \sphinxtitleref{\textendash{}batch\sphinxhyphen{}worker} option).
The run function notices this and actually runs the task instead of dispatching again.

\end{description}

Additionally, you can add a \sphinxcode{\sphinxupquote{cmd\_prefix}} parameter to your class, which also
needs to be a list of strings, which are prefixed to the current command (e.g.
if you want to add a profiler to all your tasks).

\end{fulllineitems}

\index{DispatchableTask (class in b2luigi)@\spxentry{DispatchableTask}\spxextra{class in b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.DispatchableTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{DispatchableTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{b2luigi.core.task.Task}}

Instead of using the {\hyperref[\detokenize{documentation/api:b2luigi.dispatch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dispatch}}}}} function wrapper,
you can also inherit from this class.
Except that, it has exactly the same functionality
as a normal {\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Task}}}}}.

\begin{sphinxadmonition}{important}{Important:}
You need to overload the process function
instead of the run function in this case!
\end{sphinxadmonition}
\index{process() (b2luigi.DispatchableTask method)@\spxentry{process()}\spxextra{b2luigi.DispatchableTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.DispatchableTask.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{}{}
Override this method with your normal run function.
Do not touch the run function itself!

\end{fulllineitems}


\end{fulllineitems}



\subsection{Parameters}
\label{\detokenize{documentation/api:parameters}}
As \sphinxcode{\sphinxupquote{b2luigi}} automatically also imports \sphinxcode{\sphinxupquote{luigi}}, you can use all the parameters from \sphinxcode{\sphinxupquote{luigi}}
you know and love.
We have just added a single new flag called \sphinxcode{\sphinxupquote{hashed}} to the parameters constructor.
Turning it to true (it is turned off by default) will make \sphinxcode{\sphinxupquote{b2luigi}} use a hashed version
of the parameters value, when constructing output or log file paths.
This is especially useful if you have parameters, which may include “dangerous” characters, like “/” or “\{” (e.g.
when using list or dictionary parameters).
See also one of our {\hyperref[\detokenize{advanced/faq:faq-label}]{\sphinxcrossref{\DUrole{std,std-ref}{FAQ}}}}.


\subsection{Settings}
\label{\detokenize{documentation/api:settings}}\index{get\_setting() (in module b2luigi)@\spxentry{get\_setting()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.get_setting}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{get\_setting}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{task}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{deprecated\_keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxcode{\sphinxupquote{b2luigi}} adds a settings management to \sphinxcode{\sphinxupquote{luigi}}
and also uses it at various places.
Many batch systems, the output and log path, the environment
etc. is controlled via these settings.

There are four ways settings could be defined.
They are used in the following order (an earlier setting
overrides a later one):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
If the currently processed (or scheduled) task has a property
of the given name, it is used.
Please note that you can either set the property directly, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{batch\PYGZus{}system} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{htcondor}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

or by using a function (which might even depend on the parameters)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{batch\PYGZus{}system}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{htcondor}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

The latter is especially useful for batch system specific settings
such as requested wall time etc.

\item {} 
Settings set directly by the user in your script with a call to
{\hyperref[\detokenize{documentation/api:b2luigi.set_setting}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.set\_setting()}}}}}.

\item {} 
Settings specified in the \sphinxcode{\sphinxupquote{settings.json}} in the folder of your
script \sphinxstyleemphasis{or any folder above that}.
This makes it possible to have general project settings (e.g. the output path
or the batch system) and a specific \sphinxcode{\sphinxupquote{settings.json}} for your sub\sphinxhyphen{}project.

\end{enumerate}

With this function, you can get the current value of a specific setting with the given key.
If there is no setting defined with this name,
either the default is returned or, if you did not supply any default, a value error is raised.

Settings can be of any type, but are mostly strings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxcode{\sphinxupquote{str}}) \textendash{} The name of the parameter to query.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{task}} \textendash{} ({\hyperref[\detokenize{documentation/api:b2luigi.Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.Task}}}}}): If given, check if the task has a parameter
with this name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{default}} (\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If there is no setting which the name,
either return this default or if it is not set,
raise a ValueError.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deprecated\_keys}} (\sphinxcode{\sphinxupquote{List}}) \textendash{} Former names of this setting,
will throw a warning when still used

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_setting() (in module b2luigi)@\spxentry{set\_setting()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.set_setting}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{set\_setting}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{value}}}{}
Set the setting with the specified name \sphinxhyphen{} overriding any \sphinxcode{\sphinxupquote{setting.json}}.
If you want to have task specific settings, create a
parameter with the given name or your task.

\end{fulllineitems}

\index{clear\_setting() (in module b2luigi)@\spxentry{clear\_setting()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.clear_setting}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{clear\_setting}}}{\emph{\DUrole{n}{key}}}{}
Clear the setting with the given key

\end{fulllineitems}



\subsection{Other functions}
\label{\detokenize{documentation/api:other-functions}}\index{on\_temporary\_files() (in module b2luigi)@\spxentry{on\_temporary\_files()}\spxextra{in module b2luigi}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.on_temporary_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.}}\sphinxbfcode{\sphinxupquote{on\_temporary\_files}}}{\emph{\DUrole{n}{run\_function}}}{}
Wrapper for decorating a task’s run function to use temporary files as outputs.

A common problem when using long running tasks in luigi is the so called thanksgiving bug
(see \sphinxurl{https://www.arashrouhani.com/luigi-budapest-bi-oct-2015/\#/21}).
It occurs, when you define an output of a task and in its run function,
you create this output before filling it with content
(maybe even only after a long lasting calculation).
It may happen, that during the creation of the output and the finish of the calculation
some other tasks checks if the output is already there, finds it and assumes,
that the task is already finished (although there is probably only non\sphinxhyphen{}sense in the file
so far).

A solution is already given by luigi itself, when using the temporary\_path() function
of the file system targets, which is really nice!
Unfortunately, this means you have to open all your output files with a context manager
and this is very hard to do if you have external tasks also (because they will
probably use the output file directly instead of the temporary file version of if).

This wrapper simplifies the usage of the temporary files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{b2luigi}

\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n+nd}{@b2luigi}\PYG{o}{.}\PYG{n}{on\PYGZus{}temporary\PYGZus{}files}
    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Instead of creating the file “test.txt” at the beginning and filling it with content
later (which will never happen because of the exception thrown, which makes the file
existing but the task actually not finished), the file will be written to a temporary
file first and copied to its final location at the end of the run function (but only if there
was no error).

\sphinxstyleemphasis{Attention}:

The decorator only edits the function get\_output\_file\_name. If you are using
the output directly, you have to take care of using the temporary path correctly by yourself!

\end{fulllineitems}

\index{product\_dict() (in module b2luigi.core.utils)@\spxentry{product\_dict()}\spxextra{in module b2luigi.core.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/api:b2luigi.core.utils.product_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.core.utils.}}\sphinxbfcode{\sphinxupquote{product\_dict}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Cross\sphinxhyphen{}product the given parameters and return a list of dictionaries.
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{product\PYGZus{}dict}\PYG{p}{(}\PYG{n}{arg\PYGZus{}1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arg\PYGZus{}2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}arg\PYGZus{}1\PYGZsq{}: 1, \PYGZsq{}arg\PYGZus{}2\PYGZsq{}: 3\PYGZcb{}, \PYGZob{}\PYGZsq{}arg\PYGZus{}1\PYGZsq{}: 1, \PYGZsq{}arg\PYGZus{}2\PYGZsq{}: 4\PYGZcb{}, \PYGZob{}\PYGZsq{}arg\PYGZus{}1\PYGZsq{}: 2, \PYGZsq{}arg\PYGZus{}2\PYGZsq{}: 3\PYGZcb{}, \PYGZob{}\PYGZsq{}arg\PYGZus{}1\PYGZsq{}: 2, \PYGZsq{}arg\PYGZus{}2\PYGZsq{}: 4\PYGZcb{}]}
\end{sphinxVerbatim}

The thus produced list can directly be used as inputs for a required tasks:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{requires}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{args} \PYG{o+ow}{in} \PYG{n}{product\PYGZus{}dict}\PYG{p}{(}\PYG{n}{arg\PYGZus{}1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{arg\PYGZus{}2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{some\PYGZus{}task}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} Each keyword argument should be an iterable

\item[{Returns}] \leavevmode
A list of kwargs where each list of input keyword arguments is cross\sphinxhyphen{}multiplied with every other.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{b2luigi.basf2\_helper package}
\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi-basf2-helper-package}}\label{\detokenize{documentation/b2luigi.basf2_helper::doc}}

\paragraph{b2luigi.basf2\_helper.data module}
\label{\detokenize{documentation/b2luigi.basf2_helper:module-b2luigi.basf2_helper.data}}\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi-basf2-helper-data-module}}\index{module@\spxentry{module}!b2luigi.basf2\_helper.data@\spxentry{b2luigi.basf2\_helper.data}}\index{b2luigi.basf2\_helper.data@\spxentry{b2luigi.basf2\_helper.data}!module@\spxentry{module}}\index{CdstDataTask (class in b2luigi.basf2\_helper.data)@\spxentry{CdstDataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.CdstDataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{CdstDataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.DstDataTask}}}}}
\index{data\_mode (b2luigi.basf2\_helper.data.CdstDataTask attribute)@\spxentry{data\_mode}\spxextra{b2luigi.basf2\_helper.data.CdstDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.CdstDataTask.data_mode}}\pysigline{\sphinxbfcode{\sphinxupquote{data\_mode}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}cdst\textquotesingle{}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.data.CdstDataTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.data.CdstDataTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.CdstDataTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}


\end{fulllineitems}

\index{DataMode (class in b2luigi.basf2\_helper.data)@\spxentry{DataMode}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataMode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{DataMode}}}
Bases: \sphinxcode{\sphinxupquote{enum.Enum}}

An enumeration.
\index{cdst (b2luigi.basf2\_helper.data.DataMode attribute)@\spxentry{cdst}\spxextra{b2luigi.basf2\_helper.data.DataMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataMode.cdst}}\pysigline{\sphinxbfcode{\sphinxupquote{cdst}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}cdst\textquotesingle{}}}}
\end{fulllineitems}

\index{mdst (b2luigi.basf2\_helper.data.DataMode attribute)@\spxentry{mdst}\spxextra{b2luigi.basf2\_helper.data.DataMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataMode.mdst}}\pysigline{\sphinxbfcode{\sphinxupquote{mdst}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}mdst\textquotesingle{}}}}
\end{fulllineitems}

\index{raw (b2luigi.basf2\_helper.data.DataMode attribute)@\spxentry{raw}\spxextra{b2luigi.basf2\_helper.data.DataMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataMode.raw}}\pysigline{\sphinxbfcode{\sphinxupquote{raw}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}raw\textquotesingle{}}}}
\end{fulllineitems}

\index{skimmed\_raw (b2luigi.basf2\_helper.data.DataMode attribute)@\spxentry{skimmed\_raw}\spxextra{b2luigi.basf2\_helper.data.DataMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataMode.skimmed_raw}}\pysigline{\sphinxbfcode{\sphinxupquote{skimmed\_raw}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}skimmed\_raw\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{DataTask (class in b2luigi.basf2\_helper.data)@\spxentry{DataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{DataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{b2luigi.core.task.ExternalTask}}
\index{data\_mode (b2luigi.basf2\_helper.data.DataTask attribute)@\spxentry{data\_mode}\spxextra{b2luigi.basf2\_helper.data.DataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask.data_mode}}\pysigline{\sphinxbfcode{\sphinxupquote{data\_mode}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.EnumParameter object\textgreater{}}}}
\end{fulllineitems}

\index{experiment\_number (b2luigi.basf2\_helper.data.DataTask attribute)@\spxentry{experiment\_number}\spxextra{b2luigi.basf2\_helper.data.DataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask.experiment_number}}\pysigline{\sphinxbfcode{\sphinxupquote{experiment\_number}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}

\index{file\_name (b2luigi.basf2\_helper.data.DataTask attribute)@\spxentry{file\_name}\spxextra{b2luigi.basf2\_helper.data.DataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask.file_name}}\pysigline{\sphinxbfcode{\sphinxupquote{file\_name}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.Parameter object\textgreater{}}}}
\end{fulllineitems}

\index{prefix (b2luigi.basf2\_helper.data.DataTask attribute)@\spxentry{prefix}\spxextra{b2luigi.basf2\_helper.data.DataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask.prefix}}\pysigline{\sphinxbfcode{\sphinxupquote{prefix}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.Parameter object\textgreater{}}}}
\end{fulllineitems}

\index{run\_number (b2luigi.basf2\_helper.data.DataTask attribute)@\spxentry{run\_number}\spxextra{b2luigi.basf2\_helper.data.DataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask.run_number}}\pysigline{\sphinxbfcode{\sphinxupquote{run\_number}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{DstDataTask (class in b2luigi.basf2\_helper.data)@\spxentry{DstDataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{DstDataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.DataTask}}}}}
\index{database (b2luigi.basf2\_helper.data.DstDataTask attribute)@\spxentry{database}\spxextra{b2luigi.basf2\_helper.data.DstDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask.database}}\pysigline{\sphinxbfcode{\sphinxupquote{database}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.data.DstDataTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.data.DstDataTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}

\index{prod (b2luigi.basf2\_helper.data.DstDataTask attribute)@\spxentry{prod}\spxextra{b2luigi.basf2\_helper.data.DstDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask.prod}}\pysigline{\sphinxbfcode{\sphinxupquote{prod}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}

\index{release (b2luigi.basf2\_helper.data.DstDataTask attribute)@\spxentry{release}\spxextra{b2luigi.basf2\_helper.data.DstDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask.release}}\pysigline{\sphinxbfcode{\sphinxupquote{release}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.Parameter object\textgreater{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MdstDataTask (class in b2luigi.basf2\_helper.data)@\spxentry{MdstDataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.MdstDataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{MdstDataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.DstDataTask}}}}}
\index{data\_mode (b2luigi.basf2\_helper.data.MdstDataTask attribute)@\spxentry{data\_mode}\spxextra{b2luigi.basf2\_helper.data.MdstDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.MdstDataTask.data_mode}}\pysigline{\sphinxbfcode{\sphinxupquote{data\_mode}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}mdst\textquotesingle{}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.data.MdstDataTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.data.MdstDataTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.MdstDataTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}


\end{fulllineitems}

\index{RawDataTask (class in b2luigi.basf2\_helper.data)@\spxentry{RawDataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.RawDataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{RawDataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DataTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.DataTask}}}}}
\index{data\_mode (b2luigi.basf2\_helper.data.RawDataTask attribute)@\spxentry{data\_mode}\spxextra{b2luigi.basf2\_helper.data.RawDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.RawDataTask.data_mode}}\pysigline{\sphinxbfcode{\sphinxupquote{data\_mode}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}raw\textquotesingle{}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.data.RawDataTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.data.RawDataTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.RawDataTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}


\end{fulllineitems}

\index{SkimmedRawDataTask (class in b2luigi.basf2\_helper.data)@\spxentry{SkimmedRawDataTask}\spxextra{class in b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.SkimmedRawDataTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{SkimmedRawDataTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.DstDataTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.DstDataTask}}}}}
\index{data\_mode (b2luigi.basf2\_helper.data.SkimmedRawDataTask attribute)@\spxentry{data\_mode}\spxextra{b2luigi.basf2\_helper.data.SkimmedRawDataTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.SkimmedRawDataTask.data_mode}}\pysigline{\sphinxbfcode{\sphinxupquote{data\_mode}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}skimmed\_raw\textquotesingle{}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.data.SkimmedRawDataTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.data.SkimmedRawDataTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.SkimmedRawDataTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}


\end{fulllineitems}

\index{clone\_on\_cdst() (in module b2luigi.basf2\_helper.data)@\spxentry{clone\_on\_cdst()}\spxextra{in module b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.clone_on_cdst}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{clone\_on\_cdst}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{task\_class}}, \emph{\DUrole{n}{experiment\_number}}, \emph{\DUrole{n}{run\_number}}, \emph{\DUrole{n}{release}}, \emph{\DUrole{n}{prod}}, \emph{\DUrole{n}{database}}, \emph{\DUrole{n}{prefix}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{additional\_kwargs}}}{}
\end{fulllineitems}

\index{clone\_on\_mdst() (in module b2luigi.basf2\_helper.data)@\spxentry{clone\_on\_mdst()}\spxextra{in module b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.clone_on_mdst}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{clone\_on\_mdst}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{task\_class}}, \emph{\DUrole{n}{experiment\_number}}, \emph{\DUrole{n}{run\_number}}, \emph{\DUrole{n}{release}}, \emph{\DUrole{n}{prod}}, \emph{\DUrole{n}{database}}, \emph{\DUrole{n}{prefix}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{additional\_kwargs}}}{}
\end{fulllineitems}

\index{clone\_on\_raw() (in module b2luigi.basf2\_helper.data)@\spxentry{clone\_on\_raw()}\spxextra{in module b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.clone_on_raw}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{clone\_on\_raw}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{task\_class}}, \emph{\DUrole{n}{experiment\_number}}, \emph{\DUrole{n}{run\_number}}, \emph{\DUrole{n}{prefix}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{additional\_kwargs}}}{}
\end{fulllineitems}

\index{clone\_on\_skimmed\_raw() (in module b2luigi.basf2\_helper.data)@\spxentry{clone\_on\_skimmed\_raw()}\spxextra{in module b2luigi.basf2\_helper.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.data.clone_on_skimmed_raw}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.data.}}\sphinxbfcode{\sphinxupquote{clone\_on\_skimmed\_raw}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{task\_class}}, \emph{\DUrole{n}{experiment\_number}}, \emph{\DUrole{n}{run\_number}}, \emph{\DUrole{n}{release}}, \emph{\DUrole{n}{prod}}, \emph{\DUrole{n}{database}}, \emph{\DUrole{n}{prefix}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{file\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{additional\_kwargs}}}{}
\end{fulllineitems}



\paragraph{b2luigi.basf2\_helper.targets module}
\label{\detokenize{documentation/b2luigi.basf2_helper:module-b2luigi.basf2_helper.targets}}\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi-basf2-helper-targets-module}}\index{module@\spxentry{module}!b2luigi.basf2\_helper.targets@\spxentry{b2luigi.basf2\_helper.targets}}\index{b2luigi.basf2\_helper.targets@\spxentry{b2luigi.basf2\_helper.targets}!module@\spxentry{module}}\index{ROOTLocalTarget (class in b2luigi.basf2\_helper.targets)@\spxentry{ROOTLocalTarget}\spxextra{class in b2luigi.basf2\_helper.targets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.targets.ROOTLocalTarget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.targets.}}\sphinxbfcode{\sphinxupquote{ROOTLocalTarget}}}{\emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{format}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_tmp}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Bases: \sphinxcode{\sphinxupquote{luigi.local\_target.LocalTarget}}
\index{exists() (b2luigi.basf2\_helper.targets.ROOTLocalTarget method)@\spxentry{exists()}\spxextra{b2luigi.basf2\_helper.targets.ROOTLocalTarget method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.targets.ROOTLocalTarget.exists}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exists}}}{}{}
Returns \sphinxcode{\sphinxupquote{True}} if the path for this FileSystemTarget exists; \sphinxcode{\sphinxupquote{False}} otherwise.

This method is implemented by using \sphinxcode{\sphinxupquote{fs}}.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{b2luigi.basf2\_helper.tasks module}
\label{\detokenize{documentation/b2luigi.basf2_helper:module-b2luigi.basf2_helper.tasks}}\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi-basf2-helper-tasks-module}}\index{module@\spxentry{module}!b2luigi.basf2\_helper.tasks@\spxentry{b2luigi.basf2\_helper.tasks}}\index{b2luigi.basf2\_helper.tasks@\spxentry{b2luigi.basf2\_helper.tasks}!module@\spxentry{module}}\index{Basf2FileMergeTask (class in b2luigi.basf2\_helper.tasks)@\spxentry{Basf2FileMergeTask}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2FileMergeTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{Basf2FileMergeTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.MergerTask}}}}}
\index{cmd (b2luigi.basf2\_helper.tasks.Basf2FileMergeTask attribute)@\spxentry{cmd}\spxextra{b2luigi.basf2\_helper.tasks.Basf2FileMergeTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2FileMergeTask.cmd}}\pysigline{\sphinxbfcode{\sphinxupquote{cmd}}\sphinxbfcode{\sphinxupquote{ = {[}\textquotesingle{}b2file\sphinxhyphen{}merge\textquotesingle{}, \textquotesingle{}\sphinxhyphen{}f\textquotesingle{}{]}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Basf2PathTask (class in b2luigi.basf2\_helper.tasks)@\spxentry{Basf2PathTask}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{Basf2PathTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.Basf2Task}}}}}
\index{create\_path() (b2luigi.basf2\_helper.tasks.Basf2PathTask method)@\spxentry{create\_path()}\spxextra{b2luigi.basf2\_helper.tasks.Basf2PathTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask.create_path}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_path}}}{}{}
\end{fulllineitems}

\index{max\_event (b2luigi.basf2\_helper.tasks.Basf2PathTask attribute)@\spxentry{max\_event}\spxextra{b2luigi.basf2\_helper.tasks.Basf2PathTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask.max_event}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_event}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}

\index{num\_processes (b2luigi.basf2\_helper.tasks.Basf2PathTask attribute)@\spxentry{num\_processes}\spxextra{b2luigi.basf2\_helper.tasks.Basf2PathTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask.num_processes}}\pysigline{\sphinxbfcode{\sphinxupquote{num\_processes}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.IntParameter object\textgreater{}}}}
\end{fulllineitems}

\index{process() (b2luigi.basf2\_helper.tasks.Basf2PathTask method)@\spxentry{process()}\spxextra{b2luigi.basf2\_helper.tasks.Basf2PathTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{}{}
Override this method with your normal run function.
Do not touch the run function itself!

\end{fulllineitems}


\end{fulllineitems}

\index{Basf2Task (class in b2luigi.basf2\_helper.tasks)@\spxentry{Basf2Task}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{Basf2Task}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: \sphinxcode{\sphinxupquote{b2luigi.core.dispatchable\_task.DispatchableTask}}
\index{get\_output\_file\_target() (b2luigi.basf2\_helper.tasks.Basf2Task method)@\spxentry{get\_output\_file\_target()}\spxextra{b2luigi.basf2\_helper.tasks.Basf2Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task.get_output_file_target}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_output\_file\_target}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\end{fulllineitems}

\index{get\_serialized\_parameters() (b2luigi.basf2\_helper.tasks.Basf2Task method)@\spxentry{get\_serialized\_parameters()}\spxextra{b2luigi.basf2\_helper.tasks.Basf2Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task.get_serialized_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_serialized\_parameters}}}{}{}
\end{fulllineitems}

\index{git\_hash (b2luigi.basf2\_helper.tasks.Basf2Task attribute)@\spxentry{git\_hash}\spxextra{b2luigi.basf2\_helper.tasks.Basf2Task attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task.git_hash}}\pysigline{\sphinxbfcode{\sphinxupquote{git\_hash}}\sphinxbfcode{\sphinxupquote{ = \textless{}luigi.parameter.Parameter object\textgreater{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Basf2nTupleMergeTask (class in b2luigi.basf2\_helper.tasks)@\spxentry{Basf2nTupleMergeTask}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2nTupleMergeTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{Basf2nTupleMergeTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.MergerTask}}}}}
\index{cmd (b2luigi.basf2\_helper.tasks.Basf2nTupleMergeTask attribute)@\spxentry{cmd}\spxextra{b2luigi.basf2\_helper.tasks.Basf2nTupleMergeTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2nTupleMergeTask.cmd}}\pysigline{\sphinxbfcode{\sphinxupquote{cmd}}\sphinxbfcode{\sphinxupquote{ = {[}\textquotesingle{}fei\_merge\_files\textquotesingle{}{]}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{HaddTask (class in b2luigi.basf2\_helper.tasks)@\spxentry{HaddTask}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.HaddTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{HaddTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.MergerTask}}}}}
\index{cmd (b2luigi.basf2\_helper.tasks.HaddTask attribute)@\spxentry{cmd}\spxextra{b2luigi.basf2\_helper.tasks.HaddTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.HaddTask.cmd}}\pysigline{\sphinxbfcode{\sphinxupquote{cmd}}\sphinxbfcode{\sphinxupquote{ = {[}\textquotesingle{}hadd\textquotesingle{}, \textquotesingle{}\sphinxhyphen{}f\textquotesingle{}{]}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MergerTask (class in b2luigi.basf2\_helper.tasks)@\spxentry{MergerTask}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{MergerTask}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2Task}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.Basf2Task}}}}}
\index{cmd (b2luigi.basf2\_helper.tasks.MergerTask attribute)@\spxentry{cmd}\spxextra{b2luigi.basf2\_helper.tasks.MergerTask attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask.cmd}}\pysigline{\sphinxbfcode{\sphinxupquote{cmd}}\sphinxbfcode{\sphinxupquote{ = {[}{]}}}}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.tasks.MergerTask method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.tasks.MergerTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}

\index{process() (b2luigi.basf2\_helper.tasks.MergerTask method)@\spxentry{process()}\spxextra{b2luigi.basf2\_helper.tasks.MergerTask method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.MergerTask.process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process}}}{}{}
Override this method with your normal run function.
Do not touch the run function itself!

\end{fulllineitems}


\end{fulllineitems}

\index{SimplifiedOutputBasf2Task (class in b2luigi.basf2\_helper.tasks)@\spxentry{SimplifiedOutputBasf2Task}\spxextra{class in b2luigi.basf2\_helper.tasks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.SimplifiedOutputBasf2Task}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.}}\sphinxbfcode{\sphinxupquote{SimplifiedOutputBasf2Task}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Bases: {\hyperref[\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.Basf2PathTask}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.tasks.Basf2PathTask}}}}}
\index{create\_path() (b2luigi.basf2\_helper.tasks.SimplifiedOutputBasf2Task method)@\spxentry{create\_path()}\spxextra{b2luigi.basf2\_helper.tasks.SimplifiedOutputBasf2Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.SimplifiedOutputBasf2Task.create_path}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_path}}}{}{}
\end{fulllineitems}

\index{output() (b2luigi.basf2\_helper.tasks.SimplifiedOutputBasf2Task method)@\spxentry{output()}\spxextra{b2luigi.basf2\_helper.tasks.SimplifiedOutputBasf2Task method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.tasks.SimplifiedOutputBasf2Task.output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output}}}{}{}
The output that this Task produces.

The output of the Task determines if the Task needs to be run\textendash{}the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single \sphinxcode{\sphinxupquote{Target}} or a list of
\sphinxcode{\sphinxupquote{Target}} instances.
\begin{description}
\item[{Implementation note}] \leavevmode
If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.

\end{description}

See \DUrole{xref,std,std-ref}{Task.output}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{b2luigi.basf2\_helper.utils module}
\label{\detokenize{documentation/b2luigi.basf2_helper:module-b2luigi.basf2_helper.utils}}\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi-basf2-helper-utils-module}}\index{module@\spxentry{module}!b2luigi.basf2\_helper.utils@\spxentry{b2luigi.basf2\_helper.utils}}\index{b2luigi.basf2\_helper.utils@\spxentry{b2luigi.basf2\_helper.utils}!module@\spxentry{module}}\index{get\_basf2\_git\_hash() (in module b2luigi.basf2\_helper.utils)@\spxentry{get\_basf2\_git\_hash()}\spxextra{in module b2luigi.basf2\_helper.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation/b2luigi.basf2_helper:b2luigi.basf2_helper.utils.get_basf2_git_hash}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{b2luigi.basf2\_helper.utils.}}\sphinxbfcode{\sphinxupquote{get\_basf2\_git\_hash}}}{}{}
\end{fulllineitems}



\section{Run Modes}
\label{\detokenize{documentation/run_modes:run-modes}}\label{\detokenize{documentation/run_modes:run-modes-label}}\label{\detokenize{documentation/run_modes::doc}}
The run mode can be chosen by calling your python file with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python file.py \PYGZhy{}\PYGZhy{}mode
\end{sphinxVerbatim}

or by calling \sphinxcode{\sphinxupquote{b2luigi.process}} with a given mode set to \sphinxcode{\sphinxupquote{True}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

where mode can be one of:
\begin{itemize}
\item {} 
\sphinxstylestrong{batch}: Run the tasks on a batch system, as described in {\hyperref[\detokenize{usage/quickstart:quick-start-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Quick Start}}}}. The maximal number of
batch jobs to run in parallel (jobs in flight) is equal to the number of workers.
This is 1 by default, so you probably want to change this.
By default, LSF is used as a batch system. If you want to change this, set the corresponding \sphinxcode{\sphinxupquote{batch\_system}}
(see {\hyperref[\detokenize{usage/batch:batch-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Batch Processing}}}}) to one of the supported systems.

\item {} 
\sphinxstylestrong{dry\sphinxhyphen{}run}: Similar to the dry\sphinxhyphen{}run funtionality of \sphinxcode{\sphinxupquote{luigi}}, this will not start any tasks but just tell
you, which tasks it would run. The exit code is 1 in case a task needs to run and 0 otherwise.

\item {} 
\sphinxstylestrong{show\sphinxhyphen{}output}: List all output files that this has produced/will produce. Files which already exist
(where the targets define, what exists mean in this case) are marked as green whereas missing targets are
marked red.

\item {} 
\sphinxstylestrong{test}: Run the tasks normally (no batch submission), but turn on debug logging of \sphinxcode{\sphinxupquote{luigi}}. Also,
do not dispatch any task (if requested) and print the output to the console instead of in log files.

\end{itemize}

Additional console arguments:
\begin{itemize}
\item {} 
\sphinxstylestrong{\textendash{}scheduler\sphinxhyphen{}host} and \sphinxstylestrong{\textendash{}scheduler\sphinxhyphen{}port}: If you have set up a central scheduler, you can pass this information
here easily. This works for batch or non\sphinxhyphen{}batch submission but is turned of for the test mode.

\end{itemize}


\subsection{Start a Central Scheduler}
\label{\detokenize{documentation/run_modes:start-a-central-scheduler}}
When the number of tasks grows, it is sometimes hard to keep track of all of them (despite the summary in the end).
For this, \sphinxcode{\sphinxupquote{luigi}} (the parent project of \sphinxcode{\sphinxupquote{b2luigi}}) brings a nice visualisation and scheduling tool called the central scheduler.

To start this you need to call the \sphinxcode{\sphinxupquote{luigid}} executable.
Where to find this depends on your installation type:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\item {} 
If you have a installed \sphinxcode{\sphinxupquote{b2luigi}} without user flag, you can just call the executable as it is already in your path:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
luigid \PYGZhy{}\PYGZhy{}port PORT
\end{sphinxVerbatim}
\end{quote}

\item {} 
If you have a local installation, luigid is installed into your home directory:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZti{}/.local/bin/luigid \PYGZhy{}\PYGZhy{}port PORT
\end{sphinxVerbatim}
\end{quote}

\end{enumerate}

The default port is 8082, but you can choose any non\sphinxhyphen{}occupied port.

The central scheduler will register the tasks you want to process and keep track of which tasks are already done.

To use this scheduler, call \sphinxcode{\sphinxupquote{b2luigi}} by giving the connection details:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python simple\PYGZhy{}task.py \PYG{o}{[}\PYGZhy{}\PYGZhy{}batch\PYG{o}{]} \PYGZhy{}\PYGZhy{}scheduler\PYGZhy{}host HOST \PYGZhy{}\PYGZhy{}scheduler\PYGZhy{}port PORT
\end{sphinxVerbatim}

which works for batch as well as non\sphinxhyphen{}batch jobs.
You can now visit the url \sphinxurl{http://HOST:PORT} with your browser and see a nice summary of the current progress
of your tasks.


\section{FAQ}
\label{\detokenize{advanced/faq:faq}}\label{\detokenize{advanced/faq:faq-label}}\label{\detokenize{advanced/faq::doc}}

\subsection{Can I specify my own paths for the log files for tasks running on a batch system?}
\label{\detokenize{advanced/faq:can-i-specify-my-own-paths-for-the-log-files-for-tasks-running-on-a-batch-system}}
\sphinxcode{\sphinxupquote{b2luigi}} will automatically create log files for the \sphinxcode{\sphinxupquote{stdout}} and \sphinxcode{\sphinxupquote{stderr}}
output of a task processed on a batch system. The paths of these log files are defined
relative to the location of the executed python file and contain the parameter of
the task.
In some cases one might one to specify other paths for the log files. To achieve this,
a own \sphinxcode{\sphinxupquote{get\_log\_file\_dir()}} method of the task class must be implemented. This method
must return a directory path for the stdout and the stderr files, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyBatchTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}log\PYGZus{}file\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{realpath}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{path} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{dirname}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{logs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{path}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{b2luigi}} will use this method if it is defined and write the log output in the respective
files. Be careful, though, as these log files will of course be overwritten if more than one
task receive the same paths to write to!


\subsection{Can I exclude one job from batch processing}
\label{\detokenize{advanced/faq:can-i-exclude-one-job-from-batch-processing}}
The setting \sphinxcode{\sphinxupquote{batch\_system}} defines which submission method is used for scheduling
your tasks when using \sphinxcode{\sphinxupquote{batch=True}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}batch}}.
In most cases, you set your \sphinxcode{\sphinxupquote{batch\_system}} globally (e.g. in a \sphinxcode{\sphinxupquote{settings.json}})
file and start all your tasks with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}batch}} or \sphinxcode{\sphinxupquote{batch=True}}.
If you want a single task to run only locally (e.g. because of constraints in
the batch farm) you can set the \sphinxcode{\sphinxupquote{batch\_system}} only for this job by adding a member to this task:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyLocalTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{batch\PYGZus{}system} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{local}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{How do I handle parameter values which include “/” (or other unusual characters)?}
\label{\detokenize{advanced/faq:how-do-i-handle-parameter-values-which-include-or-other-unusual-characters}}
\sphinxcode{\sphinxupquote{b2luigi}} automatically generates the filenames for your output or log files out of
the current tasks values in the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{result}\PYG{o}{\PYGZhy{}}\PYG{n}{path}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{param1}\PYG{o}{=}\PYG{n}{value1}\PYG{o}{/}\PYG{n}{param2}\PYG{o}{=}\PYG{n}{value2}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{filename}\PYG{o}{.}\PYG{n}{ext}
\end{sphinxVerbatim}

The values are given by the serialisation of your parameter, which is basically its string representation.
Sometimes, this representation may include characters not suitable for their usage as a path name,
e.g. “/”.
Especially when you use a \sphinxcode{\sphinxupquote{DictParameter}} or a \sphinxcode{\sphinxupquote{ListParameter}}, you might not
want to have its value in your output.
Also, if you have credentials in the parameter (what you should never do of course!), you do not
want to show them to everyone.

When using a parameter in \sphinxtitleref{b2luigi} (or any of its derivatives), they have a new flag called \sphinxcode{\sphinxupquote{hashed}}
in their constructor, which makes the path creation only using a hashed version of your parameter value.

For example will this task:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyTask}\PYG{p}{(}\PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{Task}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{my\PYGZus{}parameter} \PYG{o}{=} \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{ListParameter}\PYG{p}{(}\PYG{n}{hashed}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}output\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{output}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}to\PYGZus{}output}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{b2luigi}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{MyTask}\PYG{p}{(}\PYG{n}{my\PYGZus{}parameter}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{strange}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{items}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{with}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bad / signs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

create a file called \sphinxcode{\sphinxupquote{my\_parameter=hashed\_08928069d368e4a0f8ac02a0193e443b/test.txt}} in your output folder
instead of using the list value.


\subsection{What does the ValueError “The task id \{task.task\_id\} to be executed…” mean?}
\label{\detokenize{advanced/faq:what-does-the-valueerror-the-task-id-task-task-id-to-be-executed-mean}}
The \sphinxtitleref{ValueError} exception \sphinxtitleref{The task id \textless{}task\_id\textgreater{} to be executed by this batch worker does
not exist in the locally reproduced task graph.} is thrown by \sphinxcode{\sphinxupquote{b2luigi}} batch workers if
the task that should have been executed by this batch worker does not exist in the task
graph reproduced by the batch worker. This means that the task graph produced by the initial
\sphinxcode{\sphinxupquote{b2luigi.process}} call and the one reproduced in the batch job differ from each other.
This can be caused by a non\sphinxhyphen{}deterministic behavior of your dependency graph generation, such
as a random task parameter.


\section{Development and TODOs}
\label{\detokenize{advanced/development:development-and-todos}}\label{\detokenize{advanced/development:development-label}}\label{\detokenize{advanced/development::doc}}
You want to help developing \sphinxcode{\sphinxupquote{b2luigi}}? Great! Have your github account ready and let’s go!


\subsection{Local Development}
\label{\detokenize{advanced/development:local-development}}
You want to help developing \sphinxcode{\sphinxupquote{b2luigi}}? Great! Here are some first steps to help you dive in:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Make sure you uninstall \sphinxcode{\sphinxupquote{b2luigi}} if you have installed if from pypi

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 uninstall b2luigi
\end{sphinxVerbatim}

\item {} 
Clone the repository from github

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/nils\PYGZhy{}braun/b2luigi
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{b2luigi}} is not using \sphinxcode{\sphinxupquote{setuptools}} but the newer (and better) \sphinxhref{https://pypi.org/project/flit/}{flit} as a a builder.
Install it via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 \PYG{o}{[} \PYGZhy{}\PYGZhy{}user \PYG{o}{]} install flit
\end{sphinxVerbatim}

You can now install \sphinxcode{\sphinxupquote{b2luigi}} from the cloned git repository in development mode:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
flit install \PYGZhy{}s
\end{sphinxVerbatim}

\item {} 
The documentation is hosted on read the docs and build automatically on every commit to master.
You can (and should) also build the documentation locally by installing \sphinxcode{\sphinxupquote{sphinx}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 \PYG{o}{[} \PYGZhy{}\PYGZhy{}user \PYG{o}{]} install sphinx sphinx\PYGZhy{}autobuild
\end{sphinxVerbatim}

And starting the automatic build process in the projects root folder

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sphinx\PYGZhy{}autobuild docs build
\end{sphinxVerbatim}

The autobuild will rebuild the project whenever you change something. It displays a URL where to find
the created docs now (most likely \sphinxurl{http://127.0.0.1:8000}).
Please make sure the documentation looks fine before creating a pull request.

\item {} 
If you are a core developer and want to release a new version:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Make sure all changes are committed and merged on master

\item {} 
Use the \sphinxcode{\sphinxupquote{bumpversion}} package to update the version in the python file \sphinxcode{\sphinxupquote{b2luigi/\_\_init\_\_.py}} as well
as the git tag. \sphinxcode{\sphinxupquote{flit}} will automatically use this.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bumpversion patch/minor/major
\end{sphinxVerbatim}

\item {} 
Push the new commit and the tags

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git push
git push \PYGZhy{}\PYGZhy{}tags
\end{sphinxVerbatim}

\item {} 
Publish to pipy

\begin{sphinxVerbatim}[commandchars=\\\{\}]
flit publish
\end{sphinxVerbatim}

\end{enumerate}

At a later stage, I will try to automate this.

\end{enumerate}


\subsection{Open TODOs}
\label{\detokenize{advanced/development:open-todos}}\begin{itemize}
\item {} 
Add support for different batch systems, e.g. htcondor and a batch system discovery

\item {} 
Integrate dirac or other grid systems as another batch system

\item {} 
Add helper messages on events (e.g. failed)

\end{itemize}


\chapter{The name}
\label{\detokenize{index:the-name}}
\sphinxcode{\sphinxupquote{b2luigi}} stands for multiple things at the same time:
\begin{itemize}
\item {} 
It brings \sphinxstylestrong{b}atch to (\sphinxstylestrong{2}) luigi.

\item {} 
It helps you with the \sphinxstylestrong{b}read and \sphinxstylestrong{b}utter work in luigi (e.g. proper data management)

\item {} 
It was developed for the \sphinxhref{http://belle2.org/}{Belle II} experiment.

\end{itemize}


\chapter{The team}
\label{\detokenize{index:the-team}}
Main developer:
\begin{itemize}
\item {} 
Nils Braun (\sphinxhref{http://github.com/nils-braun}{nils\sphinxhyphen{}braun})

\end{itemize}

Features, fixing, help and testing:
\begin{itemize}
\item {} 
Felix Metzner

\item {} 
Patrick Ecker

\item {} 
Jochen Gemmler

\item {} 
Michael Eliachevitch

\item {} 
Maximilian Welsch

\end{itemize}

Stolen ideas:
\begin{itemize}
\item {} 
Implementation of SGE batch system (\sphinxhref{https://github.com/spotify/luigi/blob/master/luigi/contrib/sge.py}{sge}).

\item {} 
Implementation of LSF batch system (\sphinxhref{https://github.com/spotify/luigi/pull/2373/files}{lsf}).

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{b2luigi.basf2\_helper.data}\sphinxstyleindexpageref{documentation/b2luigi.basf2_helper:\detokenize{module-b2luigi.basf2_helper.data}}
\item\relax\sphinxstyleindexentry{b2luigi.basf2\_helper.targets}\sphinxstyleindexpageref{documentation/b2luigi.basf2_helper:\detokenize{module-b2luigi.basf2_helper.targets}}
\item\relax\sphinxstyleindexentry{b2luigi.basf2\_helper.tasks}\sphinxstyleindexpageref{documentation/b2luigi.basf2_helper:\detokenize{module-b2luigi.basf2_helper.tasks}}
\item\relax\sphinxstyleindexentry{b2luigi.basf2\_helper.utils}\sphinxstyleindexpageref{documentation/b2luigi.basf2_helper:\detokenize{module-b2luigi.basf2_helper.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}